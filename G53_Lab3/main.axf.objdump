
D:/uni/5th semester/ecse324/labs/lab3/G53_Lab3/main.axf:     file format elf32-littlearm


Disassembly of section .vectors:

00000000 <__cs3_interrupt_vector>:
   0:	18 f0 9f e5 18 f0 9f e5 18 f0 9f e5 18 f0 9f e5     ................
  10:	18 f0 9f e5 18 f0 9f e5 18 f0 9f e5 18 f0 9f e5     ................
  20:	1c 12 00 00 28 12 00 00 34 12 00 00 40 12 00 00     ....(...4...@...
  30:	4c 12 00 00 5c 16 00 00 c4 10 00 00 58 12 00 00     L...\.......X...

Disassembly of section .text:

00000040 <__cs3_reset_generic>:
      40:	ea000026 	b	e0 <__cs3_start_asm_sim>

00000044 <__cs3_start_c>:
      44:	e59f608c 	ldr	r6, [pc, #140]	; d8 <__cs3_start_c+0x94>
      48:	e3560000 	cmp	r6, #0
      4c:	e92d4080 	push	{r7, lr}
      50:	e2466001 	sub	r6, r6, #1
      54:	0a00001e 	beq	d4 <__cs3_start_c+0x90>
      58:	e59f507c 	ldr	r5, [pc, #124]	; dc <__cs3_start_c+0x98>
      5c:	e3a00000 	mov	r0, #0
      60:	e3a01000 	mov	r1, #0
      64:	e515200c 	ldr	r2, [r5, #-12]
      68:	e515e010 	ldr	lr, [r5, #-16]
      6c:	e5154008 	ldr	r4, [r5, #-8]
      70:	e15e0002 	cmp	lr, r2
      74:	00822004 	addeq	r2, r2, r4
      78:	0a000009 	beq	a4 <__cs3_start_c+0x60>
      7c:	e3540000 	cmp	r4, #0
      80:	0a000007 	beq	a4 <__cs3_start_c+0x60>
      84:	e1a07002 	mov	r7, r2
      88:	e1a0c002 	mov	r12, r2
      8c:	e8be000c 	ldm	lr!, {r2, r3}
      90:	e8ac000c 	stmia	r12!, {r2, r3}
      94:	e067300c 	rsb	r3, r7, r12
      98:	e1540003 	cmp	r4, r3
      9c:	e1a0200c 	mov	r2, r12
      a0:	1afffff9 	bne	8c <__cs3_start_c+0x48>
      a4:	e515e004 	ldr	lr, [r5, #-4]
      a8:	e35e0000 	cmp	lr, #0
      ac:	11a03002 	movne	r3, r2
      b0:	0a000003 	beq	c4 <__cs3_start_c+0x80>
      b4:	e8a30003 	stmia	r3!, {r0, r1}
      b8:	e062c003 	rsb	r12, r2, r3
      bc:	e15e000c 	cmp	lr, r12
      c0:	1afffffb 	bne	b4 <__cs3_start_c+0x70>
      c4:	e2466001 	sub	r6, r6, #1
      c8:	e3760001 	cmn	r6, #1
      cc:	e2855014 	add	r5, r5, #20
      d0:	1affffe3 	bne	64 <__cs3_start_c+0x20>
      d4:	eb000547 	bl	15f8 <__cs3_premain>
      d8:	00000001 	.word	0x00000001
      dc:	0000174c 	.word	0x0000174c

000000e0 <__cs3_start_asm_sim>:
      e0:	e28f103c 	add	r1, pc, #60	; 0x3c
      e4:	e3a00016 	mov	r0, #22
      e8:	ef123456 	svc	0x00123456
      ec:	e3500000 	cmp	r0, #0
      f0:	ba000008 	blt	118 <__cs3_start_asm_sim+0x38>
      f4:	e59f2028 	ldr	r2, [pc, #40]	; 124 <__cs3_heap_start_ptr>
      f8:	e59fd01c 	ldr	sp, [pc, #28]	; 11c <__cs3_start_asm_sim+0x3c>
      fc:	e5920008 	ldr	r0, [r2, #8]
     100:	e3500000 	cmp	r0, #0
     104:	11a0d000 	movne	sp, r0
     108:	e59f1010 	ldr	r1, [pc, #16]	; 120 <__cs3_start_asm_sim+0x40>
     10c:	e5920004 	ldr	r0, [r2, #4]
     110:	e3500000 	cmp	r0, #0
     114:	15810000 	strne	r0, [r1]
     118:	eaffffc9 	b	44 <__cs3_start_c>
     11c:	3ffffff8 	.word	0x3ffffff8
     120:	00001b88 	.word	0x00001b88

00000124 <__cs3_heap_start_ptr>:
     124:	00001bb0 	.word	0x00001bb0

00000128 <_start>:
     128:	e51fd000 	ldr	sp, [pc, #-0]	; 130 <_start+0x8>
     12c:	eaffffc4 	b	44 <__cs3_start_c>
     130:	3ffffff8 	.word	0x3ffffff8

00000134 <deregister_tm_clones>:
     134:	e92d4008 	push	{r3, lr}
     138:	e59f002c 	ldr	r0, [pc, #44]	; 16c <deregister_tm_clones+0x38>
     13c:	e59f302c 	ldr	r3, [pc, #44]	; 170 <deregister_tm_clones+0x3c>
     140:	e0603003 	rsb	r3, r0, r3
     144:	e3530006 	cmp	r3, #6
     148:	8a000001 	bhi	154 <deregister_tm_clones+0x20>
     14c:	e8bd4008 	pop	{r3, lr}
     150:	e12fff1e 	bx	lr
     154:	e59f3018 	ldr	r3, [pc, #24]	; 174 <deregister_tm_clones+0x40>
     158:	e3530000 	cmp	r3, #0
     15c:	0afffffa 	beq	14c <deregister_tm_clones+0x18>
     160:	e1a0e00f 	mov	lr, pc
     164:	e12fff13 	bx	r3
     168:	eafffff7 	b	14c <deregister_tm_clones+0x18>
     16c:	00001b90 	.word	0x00001b90
     170:	00001b93 	.word	0x00001b93
     174:	00000000 	.word	0x00000000

00000178 <register_tm_clones>:
     178:	e92d4008 	push	{r3, lr}
     17c:	e59f0034 	ldr	r0, [pc, #52]	; 1b8 <register_tm_clones+0x40>
     180:	e59f3034 	ldr	r3, [pc, #52]	; 1bc <register_tm_clones+0x44>
     184:	e0603003 	rsb	r3, r0, r3
     188:	e1a03143 	asr	r3, r3, #2
     18c:	e0833fa3 	add	r3, r3, r3, lsr #31
     190:	e1b010c3 	asrs	r1, r3, #1
     194:	1a000001 	bne	1a0 <register_tm_clones+0x28>
     198:	e8bd4008 	pop	{r3, lr}
     19c:	e12fff1e 	bx	lr
     1a0:	e59f2018 	ldr	r2, [pc, #24]	; 1c0 <register_tm_clones+0x48>
     1a4:	e3520000 	cmp	r2, #0
     1a8:	0afffffa 	beq	198 <register_tm_clones+0x20>
     1ac:	e1a0e00f 	mov	lr, pc
     1b0:	e12fff12 	bx	r2
     1b4:	eafffff7 	b	198 <register_tm_clones+0x20>
     1b8:	00001b90 	.word	0x00001b90
     1bc:	00001b90 	.word	0x00001b90
     1c0:	00000000 	.word	0x00000000

000001c4 <__do_global_dtors_aux>:
     1c4:	e92d4010 	push	{r4, lr}
     1c8:	e59f402c 	ldr	r4, [pc, #44]	; 1fc <__do_global_dtors_aux+0x38>
     1cc:	e5d43000 	ldrb	r3, [r4]
     1d0:	e3530000 	cmp	r3, #0
     1d4:	1a000006 	bne	1f4 <__do_global_dtors_aux+0x30>
     1d8:	ebffffd5 	bl	134 <deregister_tm_clones>
     1dc:	e59f301c 	ldr	r3, [pc, #28]	; 200 <__do_global_dtors_aux+0x3c>
     1e0:	e3530000 	cmp	r3, #0
     1e4:	159f0018 	ldrne	r0, [pc, #24]	; 204 <__do_global_dtors_aux+0x40>
     1e8:	1320f000 	nopne	{0}
     1ec:	e3a03001 	mov	r3, #1
     1f0:	e5c43000 	strb	r3, [r4]
     1f4:	e8bd4010 	pop	{r4, lr}
     1f8:	e12fff1e 	bx	lr
     1fc:	00001b90 	.word	0x00001b90
     200:	00000000 	.word	0x00000000
     204:	000016e8 	.word	0x000016e8

00000208 <frame_dummy>:
     208:	e92d4008 	push	{r3, lr}
     20c:	e59f3034 	ldr	r3, [pc, #52]	; 248 <frame_dummy+0x40>
     210:	e3530000 	cmp	r3, #0
     214:	159f0030 	ldrne	r0, [pc, #48]	; 24c <frame_dummy+0x44>
     218:	159f1030 	ldrne	r1, [pc, #48]	; 250 <frame_dummy+0x48>
     21c:	1320f000 	nopne	{0}
     220:	e59f002c 	ldr	r0, [pc, #44]	; 254 <frame_dummy+0x4c>
     224:	e5903000 	ldr	r3, [r0]
     228:	e3530000 	cmp	r3, #0
     22c:	0a000003 	beq	240 <frame_dummy+0x38>
     230:	e59f3020 	ldr	r3, [pc, #32]	; 258 <frame_dummy+0x50>
     234:	e3530000 	cmp	r3, #0
     238:	11a0e00f 	movne	lr, pc
     23c:	112fff13 	bxne	r3
     240:	e8bd4008 	pop	{r3, lr}
     244:	eaffffcb 	b	178 <register_tm_clones>
     248:	00000000 	.word	0x00000000
     24c:	000016e8 	.word	0x000016e8
     250:	00001b94 	.word	0x00001b94
     254:	00001750 	.word	0x00001750
     258:	00000000 	.word	0x00000000

0000025c <main>:
int basicIO();
int timers();
int interruption();


int main() {
     25c:	e92d4800 	push	{r11, lr}
     260:	e28db004 	add	r11, sp, #4
	//basicIO();
	timers();
     264:	eb00003e 	bl	364 <timers>
	//interruption();
}
     268:	e1a00003 	mov	r0, r3
     26c:	e8bd8800 	pop	{r11, pc}

00000270 <basicIO>:

int basicIO(){
     270:	e92d4800 	push	{r11, lr}
     274:	e28db004 	add	r11, sp, #4
     278:	e24dd010 	sub	sp, sp, #16
     27c:	ea000000 	b	284 <basicIO+0x14>
				break;
			case 3:	
				HEX_write_ASM(HEX3, value);
				break;
		}
	}
     280:	e1a00000 	nop			; (mov r0, r0)
int basicIO(){
	
	while (1) {
		
		//Map slider content to LEDs
		int slider_content = read_slider_switches_ASM();
     284:	eb000255 	bl	be0 <read_slider_switches_ASM>
     288:	e50b0008 	str	r0, [r11, #-8]
		write_LEDs_ASM(slider_content);
     28c:	e51b0008 	ldr	r0, [r11, #-8]
     290:	eb00024e 	bl	bd0 <write_LEDs_ASM>

		//Clear HEX displays if slider9 is on
		int bit_9 = slider_content & 0x200;
     294:	e51b3008 	ldr	r3, [r11, #-8]
     298:	e2033c02 	and	r3, r3, #512	; 0x200
     29c:	e50b300c 	str	r3, [r11, #-12]
		if (bit_9 == 0x200){
     2a0:	e51b300c 	ldr	r3, [r11, #-12]
     2a4:	e3530c02 	cmp	r3, #512	; 0x200
     2a8:	1a000002 	bne	2b8 <basicIO+0x48>
			HEX_clear_ASM(HEX0 | HEX1 | HEX2 | HEX3 | HEX4 | HEX5);
     2ac:	e3a0003f 	mov	r0, #63	; 0x3f
     2b0:	eb0001ed 	bl	a6c <HEX_clear_ASM>
			continue;
     2b4:	ea000029 	b	360 <basicIO+0xf0>
		}
		else {
			HEX_flood_ASM(HEX4 | HEX5);
     2b8:	e3a00030 	mov	r0, #48	; 0x30
     2bc:	eb0001f3 	bl	a90 <HEX_flood_ASM>
		}
		
		//When button pressed, assign slider 4 least bits to HEX 3-0, depending on button pressed
		int value = slider_content & 0xF;
     2c0:	e51b3008 	ldr	r3, [r11, #-8]
     2c4:	e203300f 	and	r3, r3, #15
     2c8:	e50b3010 	str	r3, [r11, #-16]
		switch (PB_data_is_pressed_ASM(read_PB_data_ASM())){
     2cc:	eb0002cc 	bl	e04 <read_PB_data_ASM>
     2d0:	e1a03000 	mov	r3, r0
     2d4:	e6ef3073 	uxtb	r3, r3
     2d8:	e1a00003 	mov	r0, r3
     2dc:	eb0002cb 	bl	e10 <PB_data_is_pressed_ASM>
     2e0:	e1a03000 	mov	r3, r0
     2e4:	e3530003 	cmp	r3, #3
     2e8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
     2ec:	eaffffe3 	b	280 <basicIO+0x10>
     2f0:	00000300 	.word	0x00000300
     2f4:	00000318 	.word	0x00000318
     2f8:	00000330 	.word	0x00000330
     2fc:	00000348 	.word	0x00000348
			case 0:	
				HEX_write_ASM(HEX0, value);
     300:	e51b3010 	ldr	r3, [r11, #-16]
     304:	e6ef3073 	uxtb	r3, r3
     308:	e3a00001 	mov	r0, #1
     30c:	e1a01003 	mov	r1, r3
     310:	eb0001e7 	bl	ab4 <HEX_write_ASM>
				break;
     314:	ea000011 	b	360 <basicIO+0xf0>
			case 1:	
				HEX_write_ASM(HEX1, value);
     318:	e51b3010 	ldr	r3, [r11, #-16]
     31c:	e6ef3073 	uxtb	r3, r3
     320:	e3a00002 	mov	r0, #2
     324:	e1a01003 	mov	r1, r3
     328:	eb0001e1 	bl	ab4 <HEX_write_ASM>
				break;
     32c:	ea00000b 	b	360 <basicIO+0xf0>
			case 2:	
				HEX_write_ASM(HEX2, value);
     330:	e51b3010 	ldr	r3, [r11, #-16]
     334:	e6ef3073 	uxtb	r3, r3
     338:	e3a00004 	mov	r0, #4
     33c:	e1a01003 	mov	r1, r3
     340:	eb0001db 	bl	ab4 <HEX_write_ASM>
				break;
     344:	ea000005 	b	360 <basicIO+0xf0>
			case 3:	
				HEX_write_ASM(HEX3, value);
     348:	e51b3010 	ldr	r3, [r11, #-16]
     34c:	e6ef3073 	uxtb	r3, r3
     350:	e3a00008 	mov	r0, #8
     354:	e1a01003 	mov	r1, r3
     358:	eb0001d5 	bl	ab4 <HEX_write_ASM>
				break;
     35c:	e1a00000 	nop			; (mov r0, r0)
		}
	}
     360:	eaffffc6 	b	280 <basicIO+0x10>

00000364 <timers>:
	return 0;
}

int timers (){
     364:	e92d4800 	push	{r11, lr}
     368:	e28db004 	add	r11, sp, #4
     36c:	e24dd048 	sub	sp, sp, #72	; 0x48

	HPS_TIM_config_t hps_tim0;
	HPS_TIM_config_t hps_tim1;

	int count0 = 0, count1 = 0, count2 = 0, count3 = 0 , count4= 0, count5 =0;
     370:	e3a03000 	mov	r3, #0
     374:	e50b3008 	str	r3, [r11, #-8]
     378:	e3a03000 	mov	r3, #0
     37c:	e50b300c 	str	r3, [r11, #-12]
     380:	e3a03000 	mov	r3, #0
     384:	e50b3010 	str	r3, [r11, #-16]
     388:	e3a03000 	mov	r3, #0
     38c:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec
     390:	e3a03000 	mov	r3, #0
     394:	e50b3018 	str	r3, [r11, #-24]	; 0xffffffe8
     398:	e3a03000 	mov	r3, #0
     39c:	e50b301c 	str	r3, [r11, #-28]	; 0xffffffe4
	int start = 0;
     3a0:	e3a03000 	mov	r3, #0
     3a4:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0

	hps_tim0.tim = TIM0;
     3a8:	e3a03001 	mov	r3, #1
     3ac:	e54b3034 	strb	r3, [r11, #-52]	; 0xffffffcc
	hps_tim0.timeout = 10000; //for the timer
     3b0:	e3023710 	movw	r3, #10000	; 0x2710
     3b4:	e50b3030 	str	r3, [r11, #-48]	; 0xffffffd0
	hps_tim0.LD_en = 1;
     3b8:	e3a03001 	mov	r3, #1
     3bc:	e50b302c 	str	r3, [r11, #-44]	; 0xffffffd4
	hps_tim0.INT_en = 1;
     3c0:	e3a03001 	mov	r3, #1
     3c4:	e50b3028 	str	r3, [r11, #-40]	; 0xffffffd8
	hps_tim0.enable = 1;
     3c8:	e3a03001 	mov	r3, #1
     3cc:	e50b3024 	str	r3, [r11, #-36]	; 0xffffffdc
	
    hps_tim1.tim = TIM1;
     3d0:	e3a03002 	mov	r3, #2
     3d4:	e54b3048 	strb	r3, [r11, #-72]	; 0xffffffb8
	hps_tim1.timeout = 5000; //for the timer
     3d8:	e3013388 	movw	r3, #5000	; 0x1388
     3dc:	e50b3044 	str	r3, [r11, #-68]	; 0xffffffbc
	hps_tim1.LD_en = 1;
     3e0:	e3a03001 	mov	r3, #1
     3e4:	e50b3040 	str	r3, [r11, #-64]	; 0xffffffc0
	hps_tim1.INT_en = 1;
     3e8:	e3a03001 	mov	r3, #1
     3ec:	e50b303c 	str	r3, [r11, #-60]	; 0xffffffc4
	hps_tim1.enable = 1;
     3f0:	e3a03001 	mov	r3, #1
     3f4:	e50b3038 	str	r3, [r11, #-56]	; 0xffffffc8

	HPS_TIM_config_ASM(&hps_tim0);
     3f8:	e24b3034 	sub	r3, r11, #52	; 0x34
     3fc:	e1a00003 	mov	r0, r3
     400:	eb0001fa 	bl	bf0 <HPS_TIM_config_ASM>
	HPS_TIM_config_ASM(&hps_tim1);
     404:	e24b3048 	sub	r3, r11, #72	; 0x48
     408:	e1a00003 	mov	r0, r3
     40c:	eb0001f7 	bl	bf0 <HPS_TIM_config_ASM>

	HEX_write_ASM(HEX0|HEX1|HEX2|HEX3|HEX4|HEX5, 0); //setting the hexes to 0
     410:	e3a0003f 	mov	r0, #63	; 0x3f
     414:	e3a01000 	mov	r1, #0
     418:	eb0001a5 	bl	ab4 <HEX_write_ASM>
     41c:	ea000000 	b	424 <timers+0xc0>
				HEX_write_ASM(HEX3, count3);
				HEX_write_ASM(HEX4, count4);
				HEX_write_ASM(HEX5, count5);
			}
		}
	}
     420:	e1a00000 	nop			; (mov r0, r0)
	HPS_TIM_config_ASM(&hps_tim1);

	HEX_write_ASM(HEX0|HEX1|HEX2|HEX3|HEX4|HEX5, 0); //setting the hexes to 0

	while(1){
		if(start){ //program starts means stopwatch starts
     424:	e51b3020 	ldr	r3, [r11, #-32]	; 0xffffffe0
     428:	e3530000 	cmp	r3, #0
     42c:	0a000054 	beq	584 <timers+0x220>
			if(HPS_TIM_read_INT_ASM(TIM0)){
     430:	e3a00001 	mov	r0, #1
     434:	eb000233 	bl	d08 <HPS_TIM_read_INT_ASM>
     438:	e1a03000 	mov	r3, r0
     43c:	e3530000 	cmp	r3, #0
     440:	0a00004f 	beq	584 <timers+0x220>
				HPS_TIM_clear_INT_ASM(TIM0);
     444:	e3a00001 	mov	r0, #1
     448:	eb00021d 	bl	cc4 <HPS_TIM_clear_INT_ASM>
				if(++count0 == 10){ //increment digit until its 10
     44c:	e51b3008 	ldr	r3, [r11, #-8]
     450:	e2833001 	add	r3, r3, #1
     454:	e50b3008 	str	r3, [r11, #-8]
     458:	e51b3008 	ldr	r3, [r11, #-8]
     45c:	e353000a 	cmp	r3, #10
     460:	1a000004 	bne	478 <timers+0x114>
					count0 = 0; //reset it to 0 
     464:	e3a03000 	mov	r3, #0
     468:	e50b3008 	str	r3, [r11, #-8]
					count1++; //increment the next digit
     46c:	e51b300c 	ldr	r3, [r11, #-12]
     470:	e2833001 	add	r3, r3, #1
     474:	e50b300c 	str	r3, [r11, #-12]
				}
				if(count1 == 10){	//if second digit reaches 10 reset it and increment next in line
     478:	e51b300c 	ldr	r3, [r11, #-12]
     47c:	e353000a 	cmp	r3, #10
     480:	1a000004 	bne	498 <timers+0x134>
					count1=0;
     484:	e3a03000 	mov	r3, #0
     488:	e50b300c 	str	r3, [r11, #-12]
					count2++;
     48c:	e51b3010 	ldr	r3, [r11, #-16]
     490:	e2833001 	add	r3, r3, #1
     494:	e50b3010 	str	r3, [r11, #-16]
				}
				if(count2 == 10){	//if third digit reaches 10 reset it and increment next in line
     498:	e51b3010 	ldr	r3, [r11, #-16]
     49c:	e353000a 	cmp	r3, #10
     4a0:	1a000004 	bne	4b8 <timers+0x154>
					count2=0;
     4a4:	e3a03000 	mov	r3, #0
     4a8:	e50b3010 	str	r3, [r11, #-16]
					count3++;
     4ac:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
     4b0:	e2833001 	add	r3, r3, #1
     4b4:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec
				}
				if(count3 == 6){	//if fourth digit reaches 6 reset it and increment next in line since minute was reached
     4b8:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
     4bc:	e3530006 	cmp	r3, #6
     4c0:	1a000004 	bne	4d8 <timers+0x174>
					count3=0;
     4c4:	e3a03000 	mov	r3, #0
     4c8:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec
					count4++;
     4cc:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
     4d0:	e2833001 	add	r3, r3, #1
     4d4:	e50b3018 	str	r3, [r11, #-24]	; 0xffffffe8
				}
				if(count4 == 10){	//if digit reaches 10 reset it and increment next in line
     4d8:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
     4dc:	e353000a 	cmp	r3, #10
     4e0:	1a000004 	bne	4f8 <timers+0x194>
					count4=0;
     4e4:	e3a03000 	mov	r3, #0
     4e8:	e50b3018 	str	r3, [r11, #-24]	; 0xffffffe8
					count5++;
     4ec:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
     4f0:	e2833001 	add	r3, r3, #1
     4f4:	e50b301c 	str	r3, [r11, #-28]	; 0xffffffe4
				}
				if(count5 == 6){	//if digit reaches 6 reset it since an hour was reached (60 mins hence the 6)
     4f8:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
     4fc:	e3530006 	cmp	r3, #6
     500:	1a000001 	bne	50c <timers+0x1a8>
					count5=0;					
     504:	e3a03000 	mov	r3, #0
     508:	e50b301c 	str	r3, [r11, #-28]	; 0xffffffe4
				}

				HEX_write_ASM(HEX0, count0);
     50c:	e51b3008 	ldr	r3, [r11, #-8]
     510:	e6ef3073 	uxtb	r3, r3
     514:	e3a00001 	mov	r0, #1
     518:	e1a01003 	mov	r1, r3
     51c:	eb000164 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX1, count1);
     520:	e51b300c 	ldr	r3, [r11, #-12]
     524:	e6ef3073 	uxtb	r3, r3
     528:	e3a00002 	mov	r0, #2
     52c:	e1a01003 	mov	r1, r3
     530:	eb00015f 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX2, count2);
     534:	e51b3010 	ldr	r3, [r11, #-16]
     538:	e6ef3073 	uxtb	r3, r3
     53c:	e3a00004 	mov	r0, #4
     540:	e1a01003 	mov	r1, r3
     544:	eb00015a 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX3, count3);
     548:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
     54c:	e6ef3073 	uxtb	r3, r3
     550:	e3a00008 	mov	r0, #8
     554:	e1a01003 	mov	r1, r3
     558:	eb000155 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX4, count4);
     55c:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
     560:	e6ef3073 	uxtb	r3, r3
     564:	e3a00010 	mov	r0, #16
     568:	e1a01003 	mov	r1, r3
     56c:	eb000150 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX5, count5);
     570:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
     574:	e6ef3073 	uxtb	r3, r3
     578:	e3a00020 	mov	r0, #32
     57c:	e1a01003 	mov	r1, r3
     580:	eb00014b 	bl	ab4 <HEX_write_ASM>
			}		
		}
		
		if(HPS_TIM_read_INT_ASM(TIM1)){
     584:	e3a00002 	mov	r0, #2
     588:	eb0001de 	bl	d08 <HPS_TIM_read_INT_ASM>
     58c:	e1a03000 	mov	r3, r0
     590:	e3530000 	cmp	r3, #0
     594:	0affffa1 	beq	420 <timers+0xbc>
			HPS_TIM_clear_INT_ASM(TIM1);
     598:	e3a00002 	mov	r0, #2
     59c:	eb0001c8 	bl	cc4 <HPS_TIM_clear_INT_ASM>
	
			if(PB_data_is_pressed_ASM(read_PB_data_ASM())== 0){ //button 1 presse so start the program
     5a0:	eb000217 	bl	e04 <read_PB_data_ASM>
     5a4:	e1a03000 	mov	r3, r0
     5a8:	e6ef3073 	uxtb	r3, r3
     5ac:	e1a00003 	mov	r0, r3
     5b0:	eb000216 	bl	e10 <PB_data_is_pressed_ASM>
     5b4:	e1a03000 	mov	r3, r0
     5b8:	e3530000 	cmp	r3, #0
     5bc:	1a000001 	bne	5c8 <timers+0x264>
				start = 1;
     5c0:	e3a03001 	mov	r3, #1
     5c4:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0
			}	

			if(PB_data_is_pressed_ASM(read_PB_data_ASM())== 1){ //button 2 pressed so pause program
     5c8:	eb00020d 	bl	e04 <read_PB_data_ASM>
     5cc:	e1a03000 	mov	r3, r0
     5d0:	e6ef3073 	uxtb	r3, r3
     5d4:	e1a00003 	mov	r0, r3
     5d8:	eb00020c 	bl	e10 <PB_data_is_pressed_ASM>
     5dc:	e1a03000 	mov	r3, r0
     5e0:	e3530001 	cmp	r3, #1
     5e4:	1a000016 	bne	644 <timers+0x2e0>
				start = 0;
     5e8:	e3a03000 	mov	r3, #0
     5ec:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0
     5f0:	ea000000 	b	5f8 <timers+0x294>
				while(1){
					if(PB_data_is_pressed_ASM(read_PB_data_ASM())== 0 || PB_data_is_pressed_ASM(read_PB_data_ASM())== 2){ //resume if start or reset
						start = 1;
						break;
					}
				}
     5f4:	e1a00000 	nop			; (mov r0, r0)
			}	

			if(PB_data_is_pressed_ASM(read_PB_data_ASM())== 1){ //button 2 pressed so pause program
				start = 0;
				while(1){
					if(PB_data_is_pressed_ASM(read_PB_data_ASM())== 0 || PB_data_is_pressed_ASM(read_PB_data_ASM())== 2){ //resume if start or reset
     5f8:	eb000201 	bl	e04 <read_PB_data_ASM>
     5fc:	e1a03000 	mov	r3, r0
     600:	e6ef3073 	uxtb	r3, r3
     604:	e1a00003 	mov	r0, r3
     608:	eb000200 	bl	e10 <PB_data_is_pressed_ASM>
     60c:	e1a03000 	mov	r3, r0
     610:	e3530000 	cmp	r3, #0
     614:	0a000007 	beq	638 <timers+0x2d4>
     618:	eb0001f9 	bl	e04 <read_PB_data_ASM>
     61c:	e1a03000 	mov	r3, r0
     620:	e6ef3073 	uxtb	r3, r3
     624:	e1a00003 	mov	r0, r3
     628:	eb0001f8 	bl	e10 <PB_data_is_pressed_ASM>
     62c:	e1a03000 	mov	r3, r0
     630:	e3530002 	cmp	r3, #2
     634:	1affffee 	bne	5f4 <timers+0x290>
						start = 1;
     638:	e3a03001 	mov	r3, #1
     63c:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0
						break;
     640:	e1a00000 	nop			; (mov r0, r0)
					}
				}
			}
			if(PB_data_is_pressed_ASM(read_PB_data_ASM()) == 2){ //reset button is pressed
     644:	eb0001ee 	bl	e04 <read_PB_data_ASM>
     648:	e1a03000 	mov	r3, r0
     64c:	e6ef3073 	uxtb	r3, r3
     650:	e1a00003 	mov	r0, r3
     654:	eb0001ed 	bl	e10 <PB_data_is_pressed_ASM>
     658:	e1a03000 	mov	r3, r0
     65c:	e3530002 	cmp	r3, #2
     660:	1affff6e 	bne	420 <timers+0xbc>
				count0 = 0;	
     664:	e3a03000 	mov	r3, #0
     668:	e50b3008 	str	r3, [r11, #-8]
				count1 = 0;
     66c:	e3a03000 	mov	r3, #0
     670:	e50b300c 	str	r3, [r11, #-12]
				count2 = 0;
     674:	e3a03000 	mov	r3, #0
     678:	e50b3010 	str	r3, [r11, #-16]
				count3 = 0;
     67c:	e3a03000 	mov	r3, #0
     680:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec
				count4 = 0;
     684:	e3a03000 	mov	r3, #0
     688:	e50b3018 	str	r3, [r11, #-24]	; 0xffffffe8
				count5 = 0;
     68c:	e3a03000 	mov	r3, #0
     690:	e50b301c 	str	r3, [r11, #-28]	; 0xffffffe4
				start = 0;
     694:	e3a03000 	mov	r3, #0
     698:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0

				HEX_write_ASM(HEX0, count0);
     69c:	e51b3008 	ldr	r3, [r11, #-8]
     6a0:	e6ef3073 	uxtb	r3, r3
     6a4:	e3a00001 	mov	r0, #1
     6a8:	e1a01003 	mov	r1, r3
     6ac:	eb000100 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX1, count1);
     6b0:	e51b300c 	ldr	r3, [r11, #-12]
     6b4:	e6ef3073 	uxtb	r3, r3
     6b8:	e3a00002 	mov	r0, #2
     6bc:	e1a01003 	mov	r1, r3
     6c0:	eb0000fb 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX2, count2);
     6c4:	e51b3010 	ldr	r3, [r11, #-16]
     6c8:	e6ef3073 	uxtb	r3, r3
     6cc:	e3a00004 	mov	r0, #4
     6d0:	e1a01003 	mov	r1, r3
     6d4:	eb0000f6 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX3, count3);
     6d8:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
     6dc:	e6ef3073 	uxtb	r3, r3
     6e0:	e3a00008 	mov	r0, #8
     6e4:	e1a01003 	mov	r1, r3
     6e8:	eb0000f1 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX4, count4);
     6ec:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
     6f0:	e6ef3073 	uxtb	r3, r3
     6f4:	e3a00010 	mov	r0, #16
     6f8:	e1a01003 	mov	r1, r3
     6fc:	eb0000ec 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX5, count5);
     700:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
     704:	e6ef3073 	uxtb	r3, r3
     708:	e3a00020 	mov	r0, #32
     70c:	e1a01003 	mov	r1, r3
     710:	eb0000e7 	bl	ab4 <HEX_write_ASM>
			}
		}
	}
     714:	eaffff41 	b	420 <timers+0xbc>

00000718 <interruption>:
	return 0;
}

int interruption(){
     718:	e92d4800 	push	{r11, lr}
     71c:	e28db004 	add	r11, sp, #4
     720:	e24dd038 	sub	sp, sp, #56	; 0x38
	HPS_TIM_config_t hps_tim0;

	int_setup(2, (int[]){199,73});
     724:	e30136ec 	movw	r3, #5868	; 0x16ec
     728:	e3403000 	movt	r3, #0
     72c:	e24b2028 	sub	r2, r11, #40	; 0x28
     730:	e8930003 	ldm	r3, {r0, r1}
     734:	e8820003 	stm	r2, {r0, r1}
     738:	e24b3028 	sub	r3, r11, #40	; 0x28
     73c:	e3a00002 	mov	r0, #2
     740:	e1a01003 	mov	r1, r3
     744:	eb0002d2 	bl	1294 <int_setup>
    int count0 = 0, count1 = 0, count2 = 0, count3 = 0 , count4= 0, count5 =0;
     748:	e3a03000 	mov	r3, #0
     74c:	e50b3008 	str	r3, [r11, #-8]
     750:	e3a03000 	mov	r3, #0
     754:	e50b300c 	str	r3, [r11, #-12]
     758:	e3a03000 	mov	r3, #0
     75c:	e50b3010 	str	r3, [r11, #-16]
     760:	e3a03000 	mov	r3, #0
     764:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec
     768:	e3a03000 	mov	r3, #0
     76c:	e50b3018 	str	r3, [r11, #-24]	; 0xffffffe8
     770:	e3a03000 	mov	r3, #0
     774:	e50b301c 	str	r3, [r11, #-28]	; 0xffffffe4
	int start = 0;
     778:	e3a03000 	mov	r3, #0
     77c:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0

	hps_tim0.tim = TIM0;
     780:	e3a03001 	mov	r3, #1
     784:	e54b303c 	strb	r3, [r11, #-60]	; 0xffffffc4
	hps_tim0.timeout = 10000; 
     788:	e3023710 	movw	r3, #10000	; 0x2710
     78c:	e50b3038 	str	r3, [r11, #-56]	; 0xffffffc8
	hps_tim0.LD_en = 1;
     790:	e3a03001 	mov	r3, #1
     794:	e50b3034 	str	r3, [r11, #-52]	; 0xffffffcc
	hps_tim0.INT_en = 1;
     798:	e3a03001 	mov	r3, #1
     79c:	e50b3030 	str	r3, [r11, #-48]	; 0xffffffd0
	hps_tim0.enable = 1;
     7a0:	e3a03001 	mov	r3, #1
     7a4:	e50b302c 	str	r3, [r11, #-44]	; 0xffffffd4

	HPS_TIM_config_ASM(&hps_tim0);
     7a8:	e24b303c 	sub	r3, r11, #60	; 0x3c
     7ac:	e1a00003 	mov	r0, r3
     7b0:	eb00010e 	bl	bf0 <HPS_TIM_config_ASM>

	HEX_write_ASM(HEX0|HEX1|HEX2|HEX3|HEX4|HEX5, 0); //setting the hexes to 0
     7b4:	e3a0003f 	mov	r0, #63	; 0x3f
     7b8:	e3a01000 	mov	r1, #0
     7bc:	eb0000bc 	bl	ab4 <HEX_write_ASM>
     7c0:	ea000000 	b	7c8 <interruption+0xb0>
				HEX_write_ASM(HEX2, count2);
				HEX_write_ASM(HEX3, count3);
				HEX_write_ASM(HEX4, count4);
				HEX_write_ASM(HEX5, count5);
		}
	}
     7c4:	e1a00000 	nop			; (mov r0, r0)
	HPS_TIM_config_ASM(&hps_tim0);

	HEX_write_ASM(HEX0|HEX1|HEX2|HEX3|HEX4|HEX5, 0); //setting the hexes to 0

	while(1){
		enable_PB_INT_ASM(PB0|PB1|PB2);	
     7c8:	e3a00007 	mov	r0, #7
     7cc:	eb0001b3 	bl	ea0 <enable_PB_INT_ASM>

		if(start){
     7d0:	e51b3020 	ldr	r3, [r11, #-32]	; 0xffffffe0
     7d4:	e3530000 	cmp	r3, #0
     7d8:	0a000056 	beq	938 <interruption+0x220>
			if(hps_tim_flag){//check the interrupt flag 
     7dc:	e3003d7c 	movw	r3, #3452	; 0xd7c
     7e0:	e3403000 	movt	r3, #0
     7e4:	e5933000 	ldr	r3, [r3]
     7e8:	e3530000 	cmp	r3, #0
     7ec:	0a000051 	beq	938 <interruption+0x220>
				hps_tim_flag = 0;
     7f0:	e3003d7c 	movw	r3, #3452	; 0xd7c
     7f4:	e3403000 	movt	r3, #0
     7f8:	e3a02000 	mov	r2, #0
     7fc:	e5832000 	str	r2, [r3]
				if(++count0 == 10){ //increment digit until its 10
     800:	e51b3008 	ldr	r3, [r11, #-8]
     804:	e2833001 	add	r3, r3, #1
     808:	e50b3008 	str	r3, [r11, #-8]
     80c:	e51b3008 	ldr	r3, [r11, #-8]
     810:	e353000a 	cmp	r3, #10
     814:	1a000004 	bne	82c <interruption+0x114>
					count0 = 0; //reset it to 0 
     818:	e3a03000 	mov	r3, #0
     81c:	e50b3008 	str	r3, [r11, #-8]
					count1++; //increment the next digit
     820:	e51b300c 	ldr	r3, [r11, #-12]
     824:	e2833001 	add	r3, r3, #1
     828:	e50b300c 	str	r3, [r11, #-12]
				}
				if(count1 == 10){	//if second digit reaches 10 reset it and increment next in line
     82c:	e51b300c 	ldr	r3, [r11, #-12]
     830:	e353000a 	cmp	r3, #10
     834:	1a000004 	bne	84c <interruption+0x134>
					count1=0;
     838:	e3a03000 	mov	r3, #0
     83c:	e50b300c 	str	r3, [r11, #-12]
					count2++;
     840:	e51b3010 	ldr	r3, [r11, #-16]
     844:	e2833001 	add	r3, r3, #1
     848:	e50b3010 	str	r3, [r11, #-16]
				}
				if(count2 == 10){	//if third digit reaches 10 reset it and increment next in line
     84c:	e51b3010 	ldr	r3, [r11, #-16]
     850:	e353000a 	cmp	r3, #10
     854:	1a000004 	bne	86c <interruption+0x154>
					count2=0;
     858:	e3a03000 	mov	r3, #0
     85c:	e50b3010 	str	r3, [r11, #-16]
					count3++;
     860:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
     864:	e2833001 	add	r3, r3, #1
     868:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec
				}
				if(count3 == 6){	//if fourth digit reaches 6 reset it and increment next in line since minute was reached
     86c:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
     870:	e3530006 	cmp	r3, #6
     874:	1a000004 	bne	88c <interruption+0x174>
					count3=0;
     878:	e3a03000 	mov	r3, #0
     87c:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec
					count4++;
     880:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
     884:	e2833001 	add	r3, r3, #1
     888:	e50b3018 	str	r3, [r11, #-24]	; 0xffffffe8
				}
				if(count4 == 10){	//if digit reaches 10 reset it and increment next in line
     88c:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
     890:	e353000a 	cmp	r3, #10
     894:	1a000004 	bne	8ac <interruption+0x194>
					count4=0;
     898:	e3a03000 	mov	r3, #0
     89c:	e50b3018 	str	r3, [r11, #-24]	; 0xffffffe8
					count5++;
     8a0:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
     8a4:	e2833001 	add	r3, r3, #1
     8a8:	e50b301c 	str	r3, [r11, #-28]	; 0xffffffe4
				}
				if(count5 == 6){	//if digit reaches 6 reset it since an hour was reached (60 mins hence the 6)
     8ac:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
     8b0:	e3530006 	cmp	r3, #6
     8b4:	1a000001 	bne	8c0 <interruption+0x1a8>
					count5=0;					
     8b8:	e3a03000 	mov	r3, #0
     8bc:	e50b301c 	str	r3, [r11, #-28]	; 0xffffffe4
				}

				HEX_write_ASM(HEX0, count0);
     8c0:	e51b3008 	ldr	r3, [r11, #-8]
     8c4:	e6ef3073 	uxtb	r3, r3
     8c8:	e3a00001 	mov	r0, #1
     8cc:	e1a01003 	mov	r1, r3
     8d0:	eb000077 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX1, count1);
     8d4:	e51b300c 	ldr	r3, [r11, #-12]
     8d8:	e6ef3073 	uxtb	r3, r3
     8dc:	e3a00002 	mov	r0, #2
     8e0:	e1a01003 	mov	r1, r3
     8e4:	eb000072 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX2, count2);
     8e8:	e51b3010 	ldr	r3, [r11, #-16]
     8ec:	e6ef3073 	uxtb	r3, r3
     8f0:	e3a00004 	mov	r0, #4
     8f4:	e1a01003 	mov	r1, r3
     8f8:	eb00006d 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX3, count3);
     8fc:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
     900:	e6ef3073 	uxtb	r3, r3
     904:	e3a00008 	mov	r0, #8
     908:	e1a01003 	mov	r1, r3
     90c:	eb000068 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX4, count4);
     910:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
     914:	e6ef3073 	uxtb	r3, r3
     918:	e3a00010 	mov	r0, #16
     91c:	e1a01003 	mov	r1, r3
     920:	eb000063 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX5, count5);
     924:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
     928:	e6ef3073 	uxtb	r3, r3
     92c:	e3a00020 	mov	r0, #32
     930:	e1a01003 	mov	r1, r3
     934:	eb00005e 	bl	ab4 <HEX_write_ASM>

			}
		}

		if(button_flag == 0){ //if its 0 then we resume or start depending if you were paused or not
     938:	e3003d80 	movw	r3, #3456	; 0xd80
     93c:	e3403000 	movt	r3, #0
     940:	e5933000 	ldr	r3, [r3]
     944:	e3530000 	cmp	r3, #0
     948:	1a000001 	bne	954 <interruption+0x23c>
			start = 1;
     94c:	e3a03001 	mov	r3, #1
     950:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0
		}

		if(button_flag == 1){ // if 1 we pause
     954:	e3003d80 	movw	r3, #3456	; 0xd80
     958:	e3403000 	movt	r3, #0
     95c:	e5933000 	ldr	r3, [r3]
     960:	e3530001 	cmp	r3, #1
     964:	1a000010 	bne	9ac <interruption+0x294>
			start = 0;	
     968:	e3a03000 	mov	r3, #0
     96c:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0
     970:	ea000000 	b	978 <interruption+0x260>
			while(1) {
				if(button_flag == 0 || button_flag == 2){
					start = 1;
					break;
				}
			}
     974:	e1a00000 	nop			; (mov r0, r0)
		}

		if(button_flag == 1){ // if 1 we pause
			start = 0;	
			while(1) {
				if(button_flag == 0 || button_flag == 2){
     978:	e3003d80 	movw	r3, #3456	; 0xd80
     97c:	e3403000 	movt	r3, #0
     980:	e5933000 	ldr	r3, [r3]
     984:	e3530000 	cmp	r3, #0
     988:	0a000004 	beq	9a0 <interruption+0x288>
     98c:	e3003d80 	movw	r3, #3456	; 0xd80
     990:	e3403000 	movt	r3, #0
     994:	e5933000 	ldr	r3, [r3]
     998:	e3530002 	cmp	r3, #2
     99c:	1afffff4 	bne	974 <interruption+0x25c>
					start = 1;
     9a0:	e3a03001 	mov	r3, #1
     9a4:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0
					break;
     9a8:	e1a00000 	nop			; (mov r0, r0)
				}
			}
		}

		if(button_flag == 2){ //if 2 we reset
     9ac:	e3003d80 	movw	r3, #3456	; 0xd80
     9b0:	e3403000 	movt	r3, #0
     9b4:	e5933000 	ldr	r3, [r3]
     9b8:	e3530002 	cmp	r3, #2
     9bc:	1affff80 	bne	7c4 <interruption+0xac>
				count0 = 0;	
     9c0:	e3a03000 	mov	r3, #0
     9c4:	e50b3008 	str	r3, [r11, #-8]
				count1 = 0;
     9c8:	e3a03000 	mov	r3, #0
     9cc:	e50b300c 	str	r3, [r11, #-12]
				count2 = 0;
     9d0:	e3a03000 	mov	r3, #0
     9d4:	e50b3010 	str	r3, [r11, #-16]
				count3 = 0;
     9d8:	e3a03000 	mov	r3, #0
     9dc:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec
				count4 = 0;
     9e0:	e3a03000 	mov	r3, #0
     9e4:	e50b3018 	str	r3, [r11, #-24]	; 0xffffffe8
				count5 = 0;
     9e8:	e3a03000 	mov	r3, #0
     9ec:	e50b301c 	str	r3, [r11, #-28]	; 0xffffffe4

				HEX_write_ASM(HEX0, count0);
     9f0:	e51b3008 	ldr	r3, [r11, #-8]
     9f4:	e6ef3073 	uxtb	r3, r3
     9f8:	e3a00001 	mov	r0, #1
     9fc:	e1a01003 	mov	r1, r3
     a00:	eb00002b 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX1, count1);
     a04:	e51b300c 	ldr	r3, [r11, #-12]
     a08:	e6ef3073 	uxtb	r3, r3
     a0c:	e3a00002 	mov	r0, #2
     a10:	e1a01003 	mov	r1, r3
     a14:	eb000026 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX2, count2);
     a18:	e51b3010 	ldr	r3, [r11, #-16]
     a1c:	e6ef3073 	uxtb	r3, r3
     a20:	e3a00004 	mov	r0, #4
     a24:	e1a01003 	mov	r1, r3
     a28:	eb000021 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX3, count3);
     a2c:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
     a30:	e6ef3073 	uxtb	r3, r3
     a34:	e3a00008 	mov	r0, #8
     a38:	e1a01003 	mov	r1, r3
     a3c:	eb00001c 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX4, count4);
     a40:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
     a44:	e6ef3073 	uxtb	r3, r3
     a48:	e3a00010 	mov	r0, #16
     a4c:	e1a01003 	mov	r1, r3
     a50:	eb000017 	bl	ab4 <HEX_write_ASM>
				HEX_write_ASM(HEX5, count5);
     a54:	e51b301c 	ldr	r3, [r11, #-28]	; 0xffffffe4
     a58:	e6ef3073 	uxtb	r3, r3
     a5c:	e3a00020 	mov	r0, #32
     a60:	e1a01003 	mov	r1, r3
     a64:	eb000012 	bl	ab4 <HEX_write_ASM>
		}
	}
     a68:	eaffff55 	b	7c4 <interruption+0xac>

00000a6c <HEX_clear_ASM>:
			.global HEX_clear_ASM
			.global HEX_flood_ASM
			.global HEX_write_ASM

HEX_clear_ASM:
			PUSH {R0, R2, R7}		/* Callee save */
     a6c:	e92d0085 	push	{r0, r2, r7}
			PUSH {LR}				/* Callee save */
     a70:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
			MVN R0, R0	 			/* Complement R0 */
     a74:	e1e00000 	mvn	r0, r0
			MOV R2, #255			/* Segment constant to store in every display (FF for turned on) */
     a78:	e3a020ff 	mov	r2, #255	; 0xff
			MOV R7, #10 			/* Arbitrary number assigned to differentiate calls from clear to setup*/
     a7c:	e3a0700a 	mov	r7, #10
			BL HEX_setup			/* Call subroutine that sets up registers to use */
     a80:	eb000017 	bl	ae4 <HEX_setup>
			POP {LR}				/* Callee save */
     a84:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
			POP {R0, R2, R7}		/* Callee save */
     a88:	e8bd0085 	pop	{r0, r2, r7}
			BX LR				
     a8c:	e12fff1e 	bx	lr

00000a90 <HEX_flood_ASM>:

HEX_flood_ASM:
			PUSH {R2, R7}			/* Callee save */
     a90:	e92d0084 	push	{r2, r7}
			PUSH {LR}				/* Callee save */
     a94:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
			BL HEX_clear_ASM		/* Clear passed parameters to be able to add segment constant (FF) without
     a98:	ebfffff3 	bl	a6c <HEX_clear_ASM>
									/* modifying the displays that were not included in the params */
			MOV R2, #255			/* Segment constant to store in every display (FF for turned on) */
     a9c:	e3a020ff 	mov	r2, #255	; 0xff
			MOV R7, #0				/* Differentiate from clear () */
     aa0:	e3a07000 	mov	r7, #0
			BL HEX_setup			/* Call subroutine that sets up registers to use */
     aa4:	eb00000e 	bl	ae4 <HEX_setup>
			POP {LR}				/* Callee save */
     aa8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
			POP {R2, R7}			/* Callee save */
     aac:	e8bd0084 	pop	{r2, r7}
			BX LR	
     ab0:	e12fff1e 	bx	lr

00000ab4 <HEX_write_ASM>:

HEX_write_ASM:
			PUSH {R2, R3, R6, R7}	/* Callee save */
     ab4:	e92d00cc 	push	{r2, r3, r6, r7}
			PUSH {LR}				/* Callee save */
     ab8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
			BL HEX_clear_ASM		/* Clear passed parameters to be able to add segment constant(value) without
     abc:	ebffffea 	bl	a6c <HEX_clear_ASM>
									/* modifying the displays that were not included in the params */
			MOV R7, #0				/* Differentiate from clear () */
     ac0:	e3a07000 	mov	r7, #0
			MOV R6, #4				/* Will multiply passed value of character by 4 to search in array*/
     ac4:	e3a06004 	mov	r6, #4
			MUL R1, R1, R6			/* Multiply parameter value by 4 to displace the SEGMENTS_VALUES pointer */
     ac8:	e0010691 	mul	r1, r1, r6
			LDR R3, =SEGMENT_VALUES /* Holds location to array of segment values */
     acc:	e59f30e8 	ldr	r3, [pc, #232]	; bbc <SEGMENT_VALUES+0x40>
			LDR R2, [R3, R1]		/* Load nth element of array, will be segment constant */
     ad0:	e7932001 	ldr	r2, [r3, r1]
			BL HEX_setup			/* Call subroutine that sets up registers to use */
     ad4:	eb000002 	bl	ae4 <HEX_setup>
			POP {LR}				/* Callee save */
     ad8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
			POP {R2, R3, R6, R7}	/* Callee save */
     adc:	e8bd00cc 	pop	{r2, r3, r6, r7}
			BX LR	
     ae0:	e12fff1e 	bx	lr

00000ae4 <HEX_setup>:

HEX_setup:
			PUSH {R1, R2, R3, R4, R8}	/* Callee save */
     ae4:	e92d011e 	push	{r1, r2, r3, r4, r8}
			PUSH {LR}				/* Callee save */
     ae8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)

			LDR R1, =HEX_BASE		/* R1 holds dedicated location for HEX displays (3-0). The rest are at R1 + 16 */
     aec:	e59f10cc 	ldr	r1, [pc, #204]	; bc0 <SEGMENT_VALUES+0x44>
			PUSH {R2}				/* Save segments constant in stack */
     af0:	e52d2004 	push	{r2}		; (str r2, [sp, #-4]!)
			MOV R3, #0				/* Holds counter for number of displays (0-6) times 4, useful for bit shift */
     af4:	e3a03000 	mov	r3, #0
			LDR R4, [R1]			/* Holds result to store in memory */
     af8:	e5914000 	ldr	r4, [r1]
			CMP R7, #10				/* Check whether call is coming from clear() */
     afc:	e357000a 	cmp	r7, #10
			MOVEQ R4, #0			/* Clear needs to start with 0 as result, other functions need to start
     b00:	03a04000 	moveq	r4, #0
									/* with values already in memory */
			BL HEX_loop				/* Call subroutine that will check whether a HEX display was passed as parameter */
     b04:	eb000011 	bl	b50 <HEX_loop>
			CMP R7, #10				/* Check whether call is coming from clear() */
     b08:	e357000a 	cmp	r7, #10
			LDREQ R8, [R1]			/* If call from clear(), load content in display */
     b0c:	05918000 	ldreq	r8, [r1]
			ANDEQ R4, R4, R8		/* By ANDing with R4, which contains 0 for all params that are included 
     b10:	00044008 	andeq	r4, r4, r8
									to clear and FF for all those that are not, only the displays that are
									to be cleared will be cleared, the rest will be unchanged */
			STR R4, [R1]			/* Store result in memory */
     b14:	e5814000 	str	r4, [r1]

			ADD R1, R1, #16			/* Go to next location for HEX displays (5-4) */
     b18:	e2811010 	add	r1, r1, #16
			POP {R2}				/* Retrieve segments constant */
     b1c:	e49d2004 	pop	{r2}		; (ldr r2, [sp], #4)
			MOV R3, #0				/* Reset counter for next displays location */
     b20:	e3a03000 	mov	r3, #0
			LDR R4, [R1]			/* Holds result to store in memory */
     b24:	e5914000 	ldr	r4, [r1]
			CMP R7, #10				/* Check whether call is coming from clear() */
     b28:	e357000a 	cmp	r7, #10
			MOVEQ R4, #0			/* Clear needs to start with 0 as result, other functions need to start
     b2c:	03a04000 	moveq	r4, #0
									/* with values already in memory */
			BL HEX_loop				/* Call subroutine that will check whether a HEX display was passed as parameter */
     b30:	eb000006 	bl	b50 <HEX_loop>
			CMP R7, #10				/* Check whether call is coming from clear() */
     b34:	e357000a 	cmp	r7, #10
			LDREQ R8, [R1]			/* If call from clear(), load content in display */
     b38:	05918000 	ldreq	r8, [r1]
			ANDEQ R4, R4, R8		
     b3c:	00044008 	andeq	r4, r4, r8
			STR R4, [R1]			/* Store result in memory */
     b40:	e5814000 	str	r4, [r1]

			POP {LR}				/* Callee save */
     b44:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
			POP {R1, R2, R3, R4, R8}	/* Callee save */
     b48:	e8bd011e 	pop	{r1, r2, r3, r4, r8}
			BX LR	
     b4c:	e12fff1e 	bx	lr

00000b50 <HEX_loop>:

HEX_loop:		
			PUSH {R5}				/* Callee save */
     b50:	e52d5004 	push	{r5}		; (str r5, [sp, #-4]!)
			MOV R5,	#1				/* Value that will be logical ANDed with hex value (1)*/
     b54:	e3a05001 	mov	r5, #1
			AND R5, R5, R0			/* If HEX_t value && 0x1 = 0x1, then the hex display at the given counter is included */ 	
     b58:	e0055000 	and	r5, r5, r0
			CMP R5, #1				/* If = 0x1 */
     b5c:	e3550001 	cmp	r5, #1
			ADDEQ R4, R4, R2, LSL R3	/* Left Shift constant to add to result by number of bits determined by counter */
     b60:	00844312 	addeq	r4, r4, r2, lsl r3
			LSR R0, R0, #1			/* Shift right HEX_t value by 1 bit to check for every display */
     b64:	e1a000a0 	lsr	r0, r0, #1
 			ADD R3, R3, #8			/* Counter + 8 (1 byte for each display)  */
     b68:	e2833008 	add	r3, r3, #8
			POP {R5}				/* Callee save */
     b6c:	e49d5004 	pop	{r5}		; (ldr r5, [sp], #4)
			CMP R3, #32				/* Compare counter < 32 (max left shift should be by 12 bits) */
     b70:	e3530020 	cmp	r3, #32
			BLT HEX_loop			/* If counter is less than 16, loop  */
     b74:	bafffff5 	blt	b50 <HEX_loop>
			BX LR					
     b78:	e12fff1e 	bx	lr

00000b7c <SEGMENT_VALUES>:
     b7c:	0000003f 	.word	0x0000003f
     b80:	00000006 	.word	0x00000006
     b84:	0000005b 	.word	0x0000005b
     b88:	0000004f 	.word	0x0000004f
     b8c:	00000066 	.word	0x00000066
     b90:	0000006d 	.word	0x0000006d
     b94:	0000007d 	.word	0x0000007d
     b98:	00000007 	.word	0x00000007
     b9c:	0000007f 	.word	0x0000007f
     ba0:	0000006f 	.word	0x0000006f
     ba4:	00000077 	.word	0x00000077
     ba8:	0000007c 	.word	0x0000007c
     bac:	00000039 	.word	0x00000039
     bb0:	0000005e 	.word	0x0000005e
     bb4:	00000079 	.word	0x00000079
     bb8:	00000071 	.word	0x00000071
			BL HEX_clear_ASM		/* Clear passed parameters to be able to add segment constant(value) without
									/* modifying the displays that were not included in the params */
			MOV R7, #0				/* Differentiate from clear () */
			MOV R6, #4				/* Will multiply passed value of character by 4 to search in array*/
			MUL R1, R1, R6			/* Multiply parameter value by 4 to displace the SEGMENTS_VALUES pointer */
			LDR R3, =SEGMENT_VALUES /* Holds location to array of segment values */
     bbc:	00000b7c 	.word	0x00000b7c

HEX_setup:
			PUSH {R1, R2, R3, R4, R8}	/* Callee save */
			PUSH {LR}				/* Callee save */

			LDR R1, =HEX_BASE		/* R1 holds dedicated location for HEX displays (3-0). The rest are at R1 + 16 */
     bc0:	ff200020 	.word	0xff200020

00000bc4 <read_LEDs_ASM>:
			.equ LEDs_BASE, 0xFF200000
			.global read_LEDs_ASM
			.global write_LEDs_ASM

read_LEDs_ASM:
			LDR R1, =LEDs_BASE
     bc4:	e59f1010 	ldr	r1, [pc, #16]	; bdc <write_LEDs_ASM+0xc>
			LDR R0, [R1]
     bc8:	e5910000 	ldr	r0, [r1]
			BX LR
     bcc:	e12fff1e 	bx	lr

00000bd0 <write_LEDs_ASM>:

write_LEDs_ASM:
			LDR R1, =LEDs_BASE
     bd0:	e59f1004 	ldr	r1, [pc, #4]	; bdc <write_LEDs_ASM+0xc>
			STR R0, [R1]
     bd4:	e5810000 	str	r0, [r1]
			BX LR
     bd8:	e12fff1e 	bx	lr
			.equ LEDs_BASE, 0xFF200000
			.global read_LEDs_ASM
			.global write_LEDs_ASM

read_LEDs_ASM:
			LDR R1, =LEDs_BASE
     bdc:	ff200000 	.word	0xff200000

00000be0 <read_slider_switches_ASM>:
			.text
			.equ SW_BASE, 0xFF200040
			.global read_slider_switches_ASM

read_slider_switches_ASM:
			LDR R1, =SW_BASE
     be0:	e59f1004 	ldr	r1, [pc, #4]	; bec <read_slider_switches_ASM+0xc>
			LDR R0, [R1]
     be4:	e5910000 	ldr	r0, [r1]
			BX LR
     be8:	e12fff1e 	bx	lr
			.text
			.equ SW_BASE, 0xFF200040
			.global read_slider_switches_ASM

read_slider_switches_ASM:
			LDR R1, =SW_BASE
     bec:	ff200040 	.word	0xff200040

00000bf0 <HPS_TIM_config_ASM>:
	.global HPS_TIM_config_ASM
	.global HPS_TIM_clear_INT_ASM
	.global HPS_TIM_read_INT_ASM

HPS_TIM_config_ASM:
	PUSH {R4-R7, LR}
     bf0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	MOV R1, #0
     bf4:	e3a01000 	mov	r1, #0
	MOV R2, #1
     bf8:	e3a02001 	mov	r2, #1
	LDR R7, [R0]
     bfc:	e5907000 	ldr	r7, [r0]
	B LOOP
     c00:	eaffffff 	b	c04 <LOOP>

00000c04 <LOOP>:

LOOP:
	TST R7, R2, LSL R1
     c04:	e1170112 	tst	r7, r2, lsl r1
	BEQ CONTINUE
     c08:	0a000000 	beq	c10 <CONTINUE>
	BL CONFIG
     c0c:	eb000004 	bl	c24 <CONFIG>

00000c10 <CONTINUE>:

CONTINUE:
	ADD R1, R1, #1
     c10:	e2811001 	add	r1, r1, #1
	CMP R1, #4
     c14:	e3510004 	cmp	r1, #4
	BLT LOOP
     c18:	bafffff9 	blt	c04 <LOOP>

00000c1c <DONE>:

DONE:
	POP {R4-R7, LR}
     c1c:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
	BX LR
     c20:	e12fff1e 	bx	lr

00000c24 <CONFIG>:


CONFIG:
	PUSH {LR}
     c24:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	
	LDR R3, =HPS_TIM_BASE
     c28:	e59f3148 	ldr	r3, [pc, #328]	; d78 <HPS_TIM_BASE+0x10>
	LDR R4, [R3, R1, LSL #2]
     c2c:	e7934101 	ldr	r4, [r3, r1, lsl #2]
	
	BL DISABLE
     c30:	eb000005 	bl	c4c <DISABLE>
	BL SET_LOAD_VAL
     c34:	eb000008 	bl	c5c <SET_LOAD_VAL>
	BL SET_LOAD_BIT
     c38:	eb00000e 	bl	c78 <SET_LOAD_BIT>
	BL SET_INT_BIT
     c3c:	eb000013 	bl	c90 <SET_INT_BIT>
	BL SET_EN_BIT
     c40:	eb000019 	bl	cac <SET_EN_BIT>
	
	POP {LR}
     c44:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	BX LR 
     c48:	e12fff1e 	bx	lr

00000c4c <DISABLE>:

DISABLE:
	LDR R5, [R4, #0x8]
     c4c:	e5945008 	ldr	r5, [r4, #8]
	AND R5, R5, #0xFFFFFFFE
     c50:	e3c55001 	bic	r5, r5, #1
	STR R5, [R4, #0x8]
     c54:	e5845008 	str	r5, [r4, #8]
	BX LR
     c58:	e12fff1e 	bx	lr

00000c5c <SET_LOAD_VAL>:
	
SET_LOAD_VAL:
	LDR R5, [R0, #0x4]
     c5c:	e5905004 	ldr	r5, [r0, #4]
	MOV R6, #25
     c60:	e3a06019 	mov	r6, #25
	MUL R5, R5, R6
     c64:	e0050695 	mul	r5, r5, r6
	CMP R1, #2
     c68:	e3510002 	cmp	r1, #2
	LSLLT R5, R5, #2
     c6c:	b1a05105 	lsllt	r5, r5, #2
	STR R5, [R4]
     c70:	e5845000 	str	r5, [r4]
	BX LR
     c74:	e12fff1e 	bx	lr

00000c78 <SET_LOAD_BIT>:
	
SET_LOAD_BIT:
	LDR R5, [R4, #0x8]
     c78:	e5945008 	ldr	r5, [r4, #8]
	LDR R6, [R0, #0x8]
     c7c:	e5906008 	ldr	r6, [r0, #8]
	AND R5, R5, #0xFFFFFFFD
     c80:	e3c55002 	bic	r5, r5, #2
	ORR R5, R5, R6, LSL #1
     c84:	e1855086 	orr	r5, r5, r6, lsl #1
	STR R5, [R4, #0x8]
     c88:	e5845008 	str	r5, [r4, #8]
	BX LR
     c8c:	e12fff1e 	bx	lr

00000c90 <SET_INT_BIT>:
	
SET_INT_BIT:
	LDR R5, [R4, #0x8]
     c90:	e5945008 	ldr	r5, [r4, #8]
	LDR R6, [R0, #0xC]
     c94:	e590600c 	ldr	r6, [r0, #12]
	EOR R6, R6, #0x00000001
     c98:	e2266001 	eor	r6, r6, #1
	AND R5, R5, #0xFFFFFFFB
     c9c:	e3c55004 	bic	r5, r5, #4
	ORR R5, R5, R6, LSL #2
     ca0:	e1855106 	orr	r5, r5, r6, lsl #2
	STR R5, [R4, #0x8]
     ca4:	e5845008 	str	r5, [r4, #8]
	BX LR
     ca8:	e12fff1e 	bx	lr

00000cac <SET_EN_BIT>:
	
SET_EN_BIT:
	LDR R5, [R4, #0x8]
     cac:	e5945008 	ldr	r5, [r4, #8]
	LDR R6, [R0, #0x10]
     cb0:	e5906010 	ldr	r6, [r0, #16]
	AND R5, R5, #0xFFFFFFFE
     cb4:	e3c55001 	bic	r5, r5, #1
	ORR R5, R5, R6
     cb8:	e1855006 	orr	r5, r5, r6
	STR R5, [R4, #0x8]
     cbc:	e5845008 	str	r5, [r4, #8]
	BX LR
     cc0:	e12fff1e 	bx	lr

00000cc4 <HPS_TIM_clear_INT_ASM>:

HPS_TIM_clear_INT_ASM:
	PUSH {LR}
     cc4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	MOV R1, #0
     cc8:	e3a01000 	mov	r1, #0
	MOV R2, #1
     ccc:	e3a02001 	mov	r2, #1
	B CLEAR_INT_LOOP
     cd0:	eaffffff 	b	cd4 <CLEAR_INT_LOOP>

00000cd4 <CLEAR_INT_LOOP>:

CLEAR_INT_LOOP:
	TST R0, R2, LSL R1
     cd4:	e1100112 	tst	r0, r2, lsl r1
	BEQ CLEAR_INT_CONTINUE
     cd8:	0a000000 	beq	ce0 <CLEAR_INT_CONTINUE>
	BL CLEAR_INT
     cdc:	eb000005 	bl	cf8 <CLEAR_INT>

00000ce0 <CLEAR_INT_CONTINUE>:

CLEAR_INT_CONTINUE:
	ADD R1, R1, #1
     ce0:	e2811001 	add	r1, r1, #1
	CMP R1, #4
     ce4:	e3510004 	cmp	r1, #4
	BLT CLEAR_INT_LOOP
     ce8:	bafffff9 	blt	cd4 <CLEAR_INT_LOOP>
	B CLEAR_INT_DONE
     cec:	eaffffff 	b	cf0 <CLEAR_INT_DONE>

00000cf0 <CLEAR_INT_DONE>:

CLEAR_INT_DONE:
	POP {LR}
     cf0:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	BX LR
     cf4:	e12fff1e 	bx	lr

00000cf8 <CLEAR_INT>:

CLEAR_INT:
	LDR R3, =HPS_TIM_BASE
     cf8:	e59f3078 	ldr	r3, [pc, #120]	; d78 <HPS_TIM_BASE+0x10>
	LDR R3, [R3, R1, LSL #2]
     cfc:	e7933101 	ldr	r3, [r3, r1, lsl #2]
	LDR R3, [R3, #0xC]
     d00:	e593300c 	ldr	r3, [r3, #12]
	BX LR
     d04:	e12fff1e 	bx	lr

00000d08 <HPS_TIM_read_INT_ASM>:

HPS_TIM_read_INT_ASM:
	PUSH {LR}
     d08:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	PUSH {R4}
     d0c:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
	MOV R1, #0
     d10:	e3a01000 	mov	r1, #0
	MOV R2, #1
     d14:	e3a02001 	mov	r2, #1
	MOV R4, #0
     d18:	e3a04000 	mov	r4, #0
	B READ_INT_LOOP
     d1c:	eaffffff 	b	d20 <READ_INT_LOOP>

00000d20 <READ_INT_LOOP>:

READ_INT_LOOP:
	TST R0, R2, LSL R1
     d20:	e1100112 	tst	r0, r2, lsl r1
	BEQ READ_INT_CONTINUE
     d24:	0a000000 	beq	d2c <READ_INT_CONTINUE>
	BL READ_INT
     d28:	eb000008 	bl	d50 <READ_INT>

00000d2c <READ_INT_CONTINUE>:

READ_INT_CONTINUE:
	ADD R1, R1, #1
     d2c:	e2811001 	add	r1, r1, #1
	CMP R1, #4
     d30:	e3510004 	cmp	r1, #4
	BEQ READ_INT_DONE
     d34:	0a000001 	beq	d40 <READ_INT_DONE>
	LSL R4, R4, #1
     d38:	e1a04084 	lsl	r4, r4, #1
	B READ_INT_LOOP
     d3c:	eafffff7 	b	d20 <READ_INT_LOOP>

00000d40 <READ_INT_DONE>:
	
READ_INT_DONE:
	MOV R0, R4
     d40:	e1a00004 	mov	r0, r4
	POP {R4}
     d44:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
	POP {LR}
     d48:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	BX LR
     d4c:	e12fff1e 	bx	lr

00000d50 <READ_INT>:

READ_INT:
	LDR R3, =HPS_TIM_BASE
     d50:	e59f3020 	ldr	r3, [pc, #32]	; d78 <HPS_TIM_BASE+0x10>
	LDR R3, [R3, R1, LSL #2]
     d54:	e7933101 	ldr	r3, [r3, r1, lsl #2]
	LDR R3, [R3, #0x10]
     d58:	e5933010 	ldr	r3, [r3, #16]
	AND R3, R3, #0x1
     d5c:	e2033001 	and	r3, r3, #1
	EOR R4, R4, R3
     d60:	e0244003 	eor	r4, r4, r3
	BX LR
     d64:	e12fff1e 	bx	lr

00000d68 <HPS_TIM_BASE>:
     d68:	ffc08000 	.word	0xffc08000
     d6c:	ffc09000 	.word	0xffc09000
     d70:	ffd00000 	.word	0xffd00000
     d74:	ffd01000 	.word	0xffd01000


CONFIG:
	PUSH {LR}
	
	LDR R3, =HPS_TIM_BASE
     d78:	00000d68 	.word	0x00000d68

00000d7c <hps_tim_flag>:
     d7c:	00000000 	.word	0x00000000

00000d80 <button_flag>:
     d80:	00000004 	.word	0x00000004

00000d84 <A9_PRIV_TIM_ISR>:

button_flag:
	.word 0x4

A9_PRIV_TIM_ISR:
	BX LR
     d84:	e12fff1e 	bx	lr

00000d88 <HPS_GPIO1_ISR>:
	
HPS_GPIO1_ISR:
	BX LR
     d88:	e12fff1e 	bx	lr

00000d8c <HPS_TIM0_ISR>:
	
HPS_TIM0_ISR:
	PUSH {LR}
     d8c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	MOV R0, #0x1
     d90:	e3a00001 	mov	r0, #1
	BL HPS_TIM_clear_INT_ASM
     d94:	ebffffca 	bl	cc4 <HPS_TIM_clear_INT_ASM>
	LDR R0, =hps_tim_flag
     d98:	e59f005c 	ldr	r0, [pc, #92]	; dfc <FPGA_PS2_DUAL_ISR+0x4>
	MOV R1, #1
     d9c:	e3a01001 	mov	r1, #1
	STR R1, [R0]
     da0:	e5801000 	str	r1, [r0]
	POP {LR}
     da4:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	BX LR
     da8:	e12fff1e 	bx	lr

00000dac <HPS_TIM1_ISR>:
	
HPS_TIM1_ISR:
	BX LR
     dac:	e12fff1e 	bx	lr

00000db0 <HPS_TIM2_ISR>:
	
HPS_TIM2_ISR:
	BX LR
     db0:	e12fff1e 	bx	lr

00000db4 <HPS_TIM3_ISR>:
	
HPS_TIM3_ISR:
	BX LR
     db4:	e12fff1e 	bx	lr

00000db8 <FPGA_INTERVAL_TIM_ISR>:
	
FPGA_INTERVAL_TIM_ISR:
	BX LR
     db8:	e12fff1e 	bx	lr

00000dbc <FPGA_PB_KEYS_ISR>:
	
FPGA_PB_KEYS_ISR:
	PUSH {LR}
     dbc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	BL read_PB_edgecap_ASM //read and display button pressed
     dc0:	eb000024 	bl	e58 <read_PB_edgecap_ASM>
	BL PB_edgecap_is_pressed_ASM
     dc4:	eb000026 	bl	e64 <PB_edgecap_is_pressed_ASM>
	LDR R1, = button_flag
     dc8:	e59f1030 	ldr	r1, [pc, #48]	; e00 <FPGA_PS2_DUAL_ISR+0x8>
	STR R0, [R1]   //store button number
     dcc:	e5810000 	str	r0, [r1]
	MOV R0, #15
     dd0:	e3a0000f 	mov	r0, #15
	BL PB_clear_edgecp_ASM //clear edgecap
     dd4:	eb00002d 	bl	e90 <PB_clear_edgecp_ASM>
	POP {LR}
     dd8:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
	BX LR
     ddc:	e12fff1e 	bx	lr

00000de0 <FPGA_Audio_ISR>:
	
FPGA_Audio_ISR:
	BX LR
     de0:	e12fff1e 	bx	lr

00000de4 <FPGA_PS2_ISR>:
	
FPGA_PS2_ISR:
	BX LR
     de4:	e12fff1e 	bx	lr

00000de8 <FPGA_JTAG_ISR>:
	
FPGA_JTAG_ISR:
	BX LR
     de8:	e12fff1e 	bx	lr

00000dec <FPGA_IrDA_ISR>:
	
FPGA_IrDA_ISR:
	BX LR
     dec:	e12fff1e 	bx	lr

00000df0 <FPGA_JP1_ISR>:
	
FPGA_JP1_ISR:
	BX LR
     df0:	e12fff1e 	bx	lr

00000df4 <FPGA_JP2_ISR>:
	
FPGA_JP2_ISR:
	BX LR
     df4:	e12fff1e 	bx	lr

00000df8 <FPGA_PS2_DUAL_ISR>:
	
FPGA_PS2_DUAL_ISR:
	BX LR
     df8:	e12fff1e 	bx	lr
	
HPS_TIM0_ISR:
	PUSH {LR}
	MOV R0, #0x1
	BL HPS_TIM_clear_INT_ASM
	LDR R0, =hps_tim_flag
     dfc:	00000d7c 	.word	0x00000d7c
	
FPGA_PB_KEYS_ISR:
	PUSH {LR}
	BL read_PB_edgecap_ASM //read and display button pressed
	BL PB_edgecap_is_pressed_ASM
	LDR R1, = button_flag
     e00:	00000d80 	.word	0x00000d80

00000e04 <read_PB_data_ASM>:
			.global PB_edgecap_is_pressed_ASM
			.global	PB_clear_edgecp_ASM
			.global	enable_PB_INT_ASM
			.global disable_PB_INT_ASM //names and order from header files

read_PB_data_ASM:		LDR R1, =DATA
     e04:	e59f10d0 	ldr	r1, [pc, #208]	; edc <disable_PB_INT_ASM+0x18>
						LDR R0, [R1]
     e08:	e5910000 	ldr	r0, [r1]
						BX LR
     e0c:	e12fff1e 	bx	lr

00000e10 <PB_data_is_pressed_ASM>:

PB_data_is_pressed_ASM:	CMP R0, #8 //if pushbutton data is 8 branch
     e10:	e3500008 	cmp	r0, #8
						BGE P3
     e14:	aa000007 	bge	e38 <P3>
						CMP R0, #4 //if 4 branch
     e18:	e3500004 	cmp	r0, #4
						BGE P2
     e1c:	aa000007 	bge	e40 <P2>
						CMP R0, #2	//if 2 branch
     e20:	e3500002 	cmp	r0, #2
						BGE P1
     e24:	aa000007 	bge	e48 <P1>
						CMP R0, #1 //if 1 branch
     e28:	e3500001 	cmp	r0, #1
						BGE P0
     e2c:	aa000007 	bge	e50 <P0>
	
						MOV R0, #4 //else set to none
     e30:	e3a00004 	mov	r0, #4
						BX LR
     e34:	e12fff1e 	bx	lr

00000e38 <P3>:

P3:						MOV R0, #3 //button 3
     e38:	e3a00003 	mov	r0, #3
						BX LR
     e3c:	e12fff1e 	bx	lr

00000e40 <P2>:

P2:						MOV R0, #2 //button 2
     e40:	e3a00002 	mov	r0, #2
						BX LR
     e44:	e12fff1e 	bx	lr

00000e48 <P1>:

P1:						MOV R0, #1 //button 1
     e48:	e3a00001 	mov	r0, #1
						BX LR
     e4c:	e12fff1e 	bx	lr

00000e50 <P0>:

P0:						MOV R0, #0 //button 0
     e50:	e3a00000 	mov	r0, #0
						BX LR
     e54:	e12fff1e 	bx	lr

00000e58 <read_PB_edgecap_ASM>:

read_PB_edgecap_ASM:	LDR R1, =EDGECAPTURE
     e58:	e59f1080 	ldr	r1, [pc, #128]	; ee0 <disable_PB_INT_ASM+0x1c>
						LDR R0, [R1]
     e5c:	e5910000 	ldr	r0, [r1]
						BX LR
     e60:	e12fff1e 	bx	lr

00000e64 <PB_edgecap_is_pressed_ASM>:

PB_edgecap_is_pressed_ASM:	MOV R1, #4
     e64:	e3a01004 	mov	r1, #4
							TST R0, #8
     e68:	e3100008 	tst	r0, #8
							MOVNE R1, #3
     e6c:	13a01003 	movne	r1, #3
							TST R0, #4
     e70:	e3100004 	tst	r0, #4
							MOVNE R1, #2
     e74:	13a01002 	movne	r1, #2
							TST R0, #2
     e78:	e3100002 	tst	r0, #2
							MOVNE R1, #1
     e7c:	13a01001 	movne	r1, #1
							TST R0, #1
     e80:	e3100001 	tst	r0, #1
							MOVNE R1, #0
     e84:	13a01000 	movne	r1, #0
							MOV R0, R1
     e88:	e1a00001 	mov	r0, r1
							BX LR
     e8c:	e12fff1e 	bx	lr

00000e90 <PB_clear_edgecp_ASM>:

PB_clear_edgecp_ASM:		LDR R1, =EDGECAPTURE
     e90:	e59f1048 	ldr	r1, [pc, #72]	; ee0 <disable_PB_INT_ASM+0x1c>
							MOV R2, #0xFFFFFFFF //clear all
     e94:	e3e02000 	mvn	r2, #0
							STR R2, [R1]
     e98:	e5812000 	str	r2, [r1]
							BX LR
     e9c:	e12fff1e 	bx	lr

00000ea0 <enable_PB_INT_ASM>:

enable_PB_INT_ASM:			LDR R1, =INTERRUPT
     ea0:	e59f103c 	ldr	r1, [pc, #60]	; ee4 <disable_PB_INT_ASM+0x20>
							LDR R3, [R1]
     ea4:	e5913000 	ldr	r3, [r1]
							CMP R1, #0 			//if r1 is equal to 0 branch to store r0
     ea8:	e3510000 	cmp	r1, #0
							BEQ STORE
     eac:	0a000002 	beq	ebc <STORE>
							ORR R2, R0, R3 //otherwise use orr to not change the values
     eb0:	e1802003 	orr	r2, r0, r3
							STR R2, [R1]	//and then store the result
     eb4:	e5812000 	str	r2, [r1]
							BX LR
     eb8:	e12fff1e 	bx	lr

00000ebc <STORE>:

STORE:						STR R0, [R1]
     ebc:	e5810000 	str	r0, [r1]
							BX LR
     ec0:	e12fff1e 	bx	lr

00000ec4 <disable_PB_INT_ASM>:

disable_PB_INT_ASM:			LDR R1, =INTERRUPT
     ec4:	e59f1018 	ldr	r1, [pc, #24]	; ee4 <disable_PB_INT_ASM+0x20>
							LDR R1, [R1]
     ec8:	e5911000 	ldr	r1, [r1]
							MVN R0, R0  //complement r0
     ecc:	e1e00000 	mvn	r0, r0
							AND R0, R0, R1		//and it with r1 to remove the values which dont match
     ed0:	e0000001 	and	r0, r0, r1
							STR R0, [R1]
     ed4:	e5810000 	str	r0, [r1]
							BX LR
     ed8:	e12fff1e 	bx	lr
			.global PB_edgecap_is_pressed_ASM
			.global	PB_clear_edgecp_ASM
			.global	enable_PB_INT_ASM
			.global disable_PB_INT_ASM //names and order from header files

read_PB_data_ASM:		LDR R1, =DATA
     edc:	ff200050 	.word	0xff200050
						BX LR

P0:						MOV R0, #0 //button 0
						BX LR

read_PB_edgecap_ASM:	LDR R1, =EDGECAPTURE
     ee0:	ff20005c 	.word	0xff20005c
PB_clear_edgecp_ASM:		LDR R1, =EDGECAPTURE
							MOV R2, #0xFFFFFFFF //clear all
							STR R2, [R1]
							BX LR

enable_PB_INT_ASM:			LDR R1, =INTERRUPT
     ee4:	ff200058 	.word	0xff200058

00000ee8 <disable_A9_interrupts>:
#include "../inc/int_setup.h"

void disable_A9_interrupts() {
     ee8:	e52db004 	push	{r11}		; (str r11, [sp, #-4]!)
     eec:	e28db000 	add	r11, sp, #0
     ef0:	e24dd00c 	sub	sp, sp, #12
	int status = 0b11010011;
     ef4:	e3a030d3 	mov	r3, #211	; 0xd3
     ef8:	e50b3008 	str	r3, [r11, #-8]
	asm("msr cpsr, %[ps]" : : [ps]"r"(status));
     efc:	e51b3008 	ldr	r3, [r11, #-8]
     f00:	e129f003 	msr	CPSR_fc, r3
}
     f04:	e28bd000 	add	sp, r11, #0
     f08:	e8bd0800 	ldmfd	sp!, {r11}
     f0c:	e12fff1e 	bx	lr

00000f10 <enable_A9_interrupts>:

void enable_A9_interrupts() {
     f10:	e52db004 	push	{r11}		; (str r11, [sp, #-4]!)
     f14:	e28db000 	add	r11, sp, #0
     f18:	e24dd00c 	sub	sp, sp, #12
	int status = 0b01010011;
     f1c:	e3a03053 	mov	r3, #83	; 0x53
     f20:	e50b3008 	str	r3, [r11, #-8]
	asm("msr cpsr, %[ps]" : : [ps]"r"(status));
     f24:	e51b3008 	ldr	r3, [r11, #-8]
     f28:	e129f003 	msr	CPSR_fc, r3
}
     f2c:	e28bd000 	add	sp, r11, #0
     f30:	e8bd0800 	ldmfd	sp!, {r11}
     f34:	e12fff1e 	bx	lr

00000f38 <set_A9_IRQ_stack>:

void set_A9_IRQ_stack() {
     f38:	e52db004 	push	{r11}		; (str r11, [sp, #-4]!)
     f3c:	e28db000 	add	r11, sp, #0
     f40:	e24dd00c 	sub	sp, sp, #12
	int stack, mode;
	stack = 0xFFFFFFFF - 7;
     f44:	e3e03007 	mvn	r3, #7
     f48:	e50b3008 	str	r3, [r11, #-8]
	mode = 0b11010010;
     f4c:	e3a030d2 	mov	r3, #210	; 0xd2
     f50:	e50b300c 	str	r3, [r11, #-12]
	asm("msr cpsr, %[ps]" : : [ps] "r" (mode));
     f54:	e51b300c 	ldr	r3, [r11, #-12]
     f58:	e129f003 	msr	CPSR_fc, r3
	asm("mov sp, %[ps]" : : [ps] "r" (stack));
     f5c:	e51b3008 	ldr	r3, [r11, #-8]
     f60:	e1a0d003 	mov	sp, r3
	
	mode = 0b11010011;
     f64:	e3a030d3 	mov	r3, #211	; 0xd3
     f68:	e50b300c 	str	r3, [r11, #-12]
	asm("msr cpsr, %[ps]" : : [ps] "r" (mode));
     f6c:	e51b300c 	ldr	r3, [r11, #-12]
     f70:	e129f003 	msr	CPSR_fc, r3
}
     f74:	e28bd000 	add	sp, r11, #0
     f78:	e8bd0800 	ldmfd	sp!, {r11}
     f7c:	e12fff1e 	bx	lr

00000f80 <config_interrupt>:

void config_interrupt(int ID, int CPU) {
     f80:	e52db004 	push	{r11}		; (str r11, [sp, #-4]!)
     f84:	e28db000 	add	r11, sp, #0
     f88:	e24dd01c 	sub	sp, sp, #28
     f8c:	e50b0018 	str	r0, [r11, #-24]	; 0xffffffe8
     f90:	e50b101c 	str	r1, [r11, #-28]	; 0xffffffe4
	int reg_offset;
	int index;
	int value;
	int address;
	
	reg_offset = (ID>>3) & 0xFFFFFFFC;
     f94:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
     f98:	e1a031c3 	asr	r3, r3, #3
     f9c:	e3c33003 	bic	r3, r3, #3
     fa0:	e50b3008 	str	r3, [r11, #-8]
	index = ID & 0x1F;
     fa4:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
     fa8:	e203301f 	and	r3, r3, #31
     fac:	e50b300c 	str	r3, [r11, #-12]
	value = 1<<index;
     fb0:	e3a02001 	mov	r2, #1
     fb4:	e51b300c 	ldr	r3, [r11, #-12]
     fb8:	e1a03312 	lsl	r3, r2, r3
     fbc:	e50b3010 	str	r3, [r11, #-16]
	address = MPCORE_GIC_DIST + ICDISER + reg_offset;
     fc0:	e51b3008 	ldr	r3, [r11, #-8]
     fc4:	e2433b4b 	sub	r3, r3, #76800	; 0x12c00
     fc8:	e2433c03 	sub	r3, r3, #768	; 0x300
     fcc:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec
	*(int *)address |= value;
     fd0:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
     fd4:	e51b2014 	ldr	r2, [r11, #-20]	; 0xffffffec
     fd8:	e5921000 	ldr	r1, [r2]
     fdc:	e51b2010 	ldr	r2, [r11, #-16]
     fe0:	e1812002 	orr	r2, r1, r2
     fe4:	e5832000 	str	r2, [r3]
	
	reg_offset = (ID & 0xFFFFFFFC);
     fe8:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
     fec:	e3c33003 	bic	r3, r3, #3
     ff0:	e50b3008 	str	r3, [r11, #-8]
	index = ID & 3;
     ff4:	e51b3018 	ldr	r3, [r11, #-24]	; 0xffffffe8
     ff8:	e2033003 	and	r3, r3, #3
     ffc:	e50b300c 	str	r3, [r11, #-12]
	address = MPCORE_GIC_DIST + ICDIPTR + reg_offset + index;
    1000:	e51b2008 	ldr	r2, [r11, #-8]
    1004:	e51b300c 	ldr	r3, [r11, #-12]
    1008:	e0823003 	add	r3, r2, r3
    100c:	e2433b4a 	sub	r3, r3, #75776	; 0x12800
    1010:	e50b3014 	str	r3, [r11, #-20]	; 0xffffffec
	*(char *)address = (char)CPU;
    1014:	e51b3014 	ldr	r3, [r11, #-20]	; 0xffffffec
    1018:	e51b201c 	ldr	r2, [r11, #-28]	; 0xffffffe4
    101c:	e6ef2072 	uxtb	r2, r2
    1020:	e5c32000 	strb	r2, [r3]
}
    1024:	e28bd000 	add	sp, r11, #0
    1028:	e8bd0800 	ldmfd	sp!, {r11}
    102c:	e12fff1e 	bx	lr

00001030 <config_GIC>:

void config_GIC(int len, int* IDs) {
    1030:	e92d4800 	push	{r11, lr}
    1034:	e28db004 	add	r11, sp, #4
    1038:	e24dd010 	sub	sp, sp, #16
    103c:	e50b0010 	str	r0, [r11, #-16]
    1040:	e50b1014 	str	r1, [r11, #-20]	; 0xffffffec
	int i;
	for(i=0 ; i<len ; i++)
    1044:	e3a03000 	mov	r3, #0
    1048:	e50b3008 	str	r3, [r11, #-8]
    104c:	ea00000a 	b	107c <config_GIC+0x4c>
		config_interrupt(IDs[i],1);
    1050:	e51b3008 	ldr	r3, [r11, #-8]
    1054:	e1a03103 	lsl	r3, r3, #2
    1058:	e51b2014 	ldr	r2, [r11, #-20]	; 0xffffffec
    105c:	e0823003 	add	r3, r2, r3
    1060:	e5933000 	ldr	r3, [r3]
    1064:	e1a00003 	mov	r0, r3
    1068:	e3a01001 	mov	r1, #1
    106c:	ebffffc3 	bl	f80 <config_interrupt>
	*(char *)address = (char)CPU;
}

void config_GIC(int len, int* IDs) {
	int i;
	for(i=0 ; i<len ; i++)
    1070:	e51b3008 	ldr	r3, [r11, #-8]
    1074:	e2833001 	add	r3, r3, #1
    1078:	e50b3008 	str	r3, [r11, #-8]
    107c:	e51b2008 	ldr	r2, [r11, #-8]
    1080:	e51b3010 	ldr	r3, [r11, #-16]
    1084:	e1520003 	cmp	r2, r3
    1088:	bafffff0 	blt	1050 <config_GIC+0x20>
		config_interrupt(IDs[i],1);
	*((int *) (MPCORE_GIC_CPUIF + ICCPMR)) = 0xFFFF;
    108c:	e30c3104 	movw	r3, #49412	; 0xc104
    1090:	e34f3ffe 	movt	r3, #65534	; 0xfffe
    1094:	e30f2fff 	movw	r2, #65535	; 0xffff
    1098:	e5832000 	str	r2, [r3]
	*((int *) (MPCORE_GIC_CPUIF)) = 1;
    109c:	e3a03cc1 	mov	r3, #49408	; 0xc100
    10a0:	e34f3ffe 	movt	r3, #65534	; 0xfffe
    10a4:	e3a02001 	mov	r2, #1
    10a8:	e5832000 	str	r2, [r3]
	*((int *) (MPCORE_GIC_DIST)) = 1;
    10ac:	e3a03a0d 	mov	r3, #53248	; 0xd000
    10b0:	e34f3ffe 	movt	r3, #65534	; 0xfffe
    10b4:	e3a02001 	mov	r2, #1
    10b8:	e5832000 	str	r2, [r3]
}
    10bc:	e24bd004 	sub	sp, r11, #4
    10c0:	e8bd8800 	pop	{r11, pc}

000010c4 <__cs3_isr_irq>:

void __attribute__ ((interrupt)) __cs3_isr_irq() {
    10c4:	e24ee004 	sub	lr, lr, #4
    10c8:	e92d580f 	push	{r0, r1, r2, r3, r11, r12, lr}
    10cc:	e28db018 	add	r11, sp, #24
    10d0:	e24dd00c 	sub	sp, sp, #12
	int interrupt_ID = *((int *) (MPCORE_GIC_CPUIF + ICCIAR));
    10d4:	e30c310c 	movw	r3, #49420	; 0xc10c
    10d8:	e34f3ffe 	movt	r3, #65534	; 0xfffe
    10dc:	e5933000 	ldr	r3, [r3]
    10e0:	e50b3020 	str	r3, [r11, #-32]	; 0xffffffe0
	
	switch(interrupt_ID) {
    10e4:	e51b3020 	ldr	r3, [r11, #-32]	; 0xffffffe0
    10e8:	e3530053 	cmp	r3, #83	; 0x53
    10ec:	0a00003d 	beq	11e8 <__cs3_isr_irq+0x124>
    10f0:	e3530053 	cmp	r3, #83	; 0x53
    10f4:	ca000011 	bgt	1140 <__cs3_isr_irq+0x7c>
    10f8:	e353004e 	cmp	r3, #78	; 0x4e
    10fc:	0a000031 	beq	11c8 <__cs3_isr_irq+0x104>
    1100:	e353004e 	cmp	r3, #78	; 0x4e
    1104:	ca000006 	bgt	1124 <__cs3_isr_irq+0x60>
    1108:	e3530048 	cmp	r3, #72	; 0x48
    110c:	0a000029 	beq	11b8 <__cs3_isr_irq+0xf4>
    1110:	e3530049 	cmp	r3, #73	; 0x49
    1114:	0a000029 	beq	11c0 <__cs3_isr_irq+0xfc>
    1118:	e353001d 	cmp	r3, #29
    111c:	0a000019 	beq	1188 <__cs3_isr_irq+0xc4>
    1120:	ea000036 	b	1200 <__cs3_isr_irq+0x13c>
    1124:	e3530050 	cmp	r3, #80	; 0x50
    1128:	0a00002a 	beq	11d8 <__cs3_isr_irq+0x114>
    112c:	e3530050 	cmp	r3, #80	; 0x50
    1130:	ba000026 	blt	11d0 <__cs3_isr_irq+0x10c>
    1134:	e3530051 	cmp	r3, #81	; 0x51
    1138:	0a000028 	beq	11e0 <__cs3_isr_irq+0x11c>
    113c:	ea00002f 	b	1200 <__cs3_isr_irq+0x13c>
    1140:	e35300c7 	cmp	r3, #199	; 0xc7
    1144:	0a000013 	beq	1198 <__cs3_isr_irq+0xd4>
    1148:	e35300c7 	cmp	r3, #199	; 0xc7
    114c:	ca000006 	bgt	116c <__cs3_isr_irq+0xa8>
    1150:	e3530059 	cmp	r3, #89	; 0x59
    1154:	0a000027 	beq	11f8 <__cs3_isr_irq+0x134>
    1158:	e35300c5 	cmp	r3, #197	; 0xc5
    115c:	0a00000b 	beq	1190 <__cs3_isr_irq+0xcc>
    1160:	e3530054 	cmp	r3, #84	; 0x54
    1164:	0a000021 	beq	11f0 <__cs3_isr_irq+0x12c>
    1168:	ea000024 	b	1200 <__cs3_isr_irq+0x13c>
    116c:	e35300c9 	cmp	r3, #201	; 0xc9
    1170:	0a00000c 	beq	11a8 <__cs3_isr_irq+0xe4>
    1174:	e35300c9 	cmp	r3, #201	; 0xc9
    1178:	ba000008 	blt	11a0 <__cs3_isr_irq+0xdc>
    117c:	e35300ca 	cmp	r3, #202	; 0xca
    1180:	0a00000a 	beq	11b0 <__cs3_isr_irq+0xec>
    1184:	ea00001d 	b	1200 <__cs3_isr_irq+0x13c>
		
		case 29:  A9_PRIV_TIM_ISR(); break;
    1188:	ebfffefd 	bl	d84 <A9_PRIV_TIM_ISR>
    118c:	ea00001c 	b	1204 <__cs3_isr_irq+0x140>
		case 197: HPS_GPIO1_ISR(); break;
    1190:	ebfffefc 	bl	d88 <HPS_GPIO1_ISR>
    1194:	ea00001a 	b	1204 <__cs3_isr_irq+0x140>
		case 199: HPS_TIM0_ISR(); break;
    1198:	ebfffefb 	bl	d8c <HPS_TIM0_ISR>
    119c:	ea000018 	b	1204 <__cs3_isr_irq+0x140>
		case 200: HPS_TIM1_ISR(); break;
    11a0:	ebffff01 	bl	dac <HPS_TIM1_ISR>
    11a4:	ea000016 	b	1204 <__cs3_isr_irq+0x140>
		case 201: HPS_TIM2_ISR(); break;
    11a8:	ebffff00 	bl	db0 <HPS_TIM2_ISR>
    11ac:	ea000014 	b	1204 <__cs3_isr_irq+0x140>
		case 202: HPS_TIM3_ISR(); break;
    11b0:	ebfffeff 	bl	db4 <HPS_TIM3_ISR>
    11b4:	ea000012 	b	1204 <__cs3_isr_irq+0x140>
		case 72:  FPGA_INTERVAL_TIM_ISR(); break;
    11b8:	ebfffefe 	bl	db8 <FPGA_INTERVAL_TIM_ISR>
    11bc:	ea000010 	b	1204 <__cs3_isr_irq+0x140>
		case 73:  FPGA_PB_KEYS_ISR(); break;
    11c0:	ebfffefd 	bl	dbc <FPGA_PB_KEYS_ISR>
    11c4:	ea00000e 	b	1204 <__cs3_isr_irq+0x140>
		case 78:  FPGA_Audio_ISR(); break;
    11c8:	ebffff04 	bl	de0 <FPGA_Audio_ISR>
    11cc:	ea00000c 	b	1204 <__cs3_isr_irq+0x140>
		case 79:  FPGA_PS2_ISR(); break;
    11d0:	ebffff03 	bl	de4 <FPGA_PS2_ISR>
    11d4:	ea00000a 	b	1204 <__cs3_isr_irq+0x140>
		case 80:  FPGA_JTAG_ISR(); break;
    11d8:	ebffff02 	bl	de8 <FPGA_JTAG_ISR>
    11dc:	ea000008 	b	1204 <__cs3_isr_irq+0x140>
		case 81:  FPGA_IrDA_ISR(); break;
    11e0:	ebffff01 	bl	dec <FPGA_IrDA_ISR>
    11e4:	ea000006 	b	1204 <__cs3_isr_irq+0x140>
		case 83:  FPGA_JP1_ISR(); break;
    11e8:	ebffff00 	bl	df0 <FPGA_JP1_ISR>
    11ec:	ea000004 	b	1204 <__cs3_isr_irq+0x140>
		case 84:  FPGA_JP2_ISR(); break;
    11f0:	ebfffeff 	bl	df4 <FPGA_JP2_ISR>
    11f4:	ea000002 	b	1204 <__cs3_isr_irq+0x140>
		case 89:  FPGA_PS2_DUAL_ISR(); break;
    11f8:	ebfffefe 	bl	df8 <FPGA_PS2_DUAL_ISR>
    11fc:	ea000000 	b	1204 <__cs3_isr_irq+0x140>
	
		default: while(1); break;
    1200:	eafffffe 	b	1200 <__cs3_isr_irq+0x13c>
	}
	
	*((int *) (MPCORE_GIC_CPUIF + ICCEOIR)) = interrupt_ID;
    1204:	e30c3110 	movw	r3, #49424	; 0xc110
    1208:	e34f3ffe 	movt	r3, #65534	; 0xfffe
    120c:	e51b2020 	ldr	r2, [r11, #-32]	; 0xffffffe0
    1210:	e5832000 	str	r2, [r3]
}
    1214:	e24bd018 	sub	sp, r11, #24
    1218:	e8fd980f 	ldm	sp!, {r0, r1, r2, r3, r11, r12, pc}^

0000121c <__cs3_reset>:

void __attribute__ ((interrupt)) __cs3_reset (void) {
    121c:	e52db004 	push	{r11}		; (str r11, [sp, #-4]!)
    1220:	e28db000 	add	r11, sp, #0
	while(1);
    1224:	eafffffe 	b	1224 <__cs3_reset+0x8>

00001228 <__cs3_isr_undef>:
}

void __attribute__ ((interrupt)) __cs3_isr_undef (void) {
    1228:	e52db004 	push	{r11}		; (str r11, [sp, #-4]!)
    122c:	e28db000 	add	r11, sp, #0
	while(1);
    1230:	eafffffe 	b	1230 <__cs3_isr_undef+0x8>

00001234 <__cs3_isr_swi>:
}

void __attribute__ ((interrupt)) __cs3_isr_swi (void) {
    1234:	e52db004 	push	{r11}		; (str r11, [sp, #-4]!)
    1238:	e28db000 	add	r11, sp, #0
	while(1);
    123c:	eafffffe 	b	123c <__cs3_isr_swi+0x8>

00001240 <__cs3_isr_pabort>:
}

void __attribute__ ((interrupt)) __cs3_isr_pabort (void) {
    1240:	e52db004 	push	{r11}		; (str r11, [sp, #-4]!)
    1244:	e28db000 	add	r11, sp, #0
	while(1);
    1248:	eafffffe 	b	1248 <__cs3_isr_pabort+0x8>

0000124c <__cs3_isr_dabort>:
}

void __attribute__ ((interrupt)) __cs3_isr_dabort (void) {
    124c:	e52db004 	push	{r11}		; (str r11, [sp, #-4]!)
    1250:	e28db000 	add	r11, sp, #0
	while(1);
    1254:	eafffffe 	b	1254 <__cs3_isr_dabort+0x8>

00001258 <__cs3_isr_fiq>:
}

void __attribute__ ((interrupt)) __cs3_isr_fiq (void) {
    1258:	e52db004 	push	{r11}		; (str r11, [sp, #-4]!)
    125c:	e28db000 	add	r11, sp, #0
	while(1);
    1260:	eafffffe 	b	1260 <__cs3_isr_fiq+0x8>

00001264 <fix_bug>:
}

void fix_bug() {
    1264:	e52db004 	push	{r11}		; (str r11, [sp, #-4]!)
    1268:	e28db000 	add	r11, sp, #0
    126c:	e24dd00c 	sub	sp, sp, #12
	volatile int * addr = (int *)0xFFFED198;
    1270:	e30d3198 	movw	r3, #53656	; 0xd198
    1274:	e34f3ffe 	movt	r3, #65534	; 0xfffe
    1278:	e50b3008 	str	r3, [r11, #-8]
	*addr = 0x000C0000;
    127c:	e51b3008 	ldr	r3, [r11, #-8]
    1280:	e3a02703 	mov	r2, #786432	; 0xc0000
    1284:	e5832000 	str	r2, [r3]
}
    1288:	e28bd000 	add	sp, r11, #0
    128c:	e8bd0800 	ldmfd	sp!, {r11}
    1290:	e12fff1e 	bx	lr

00001294 <int_setup>:

void int_setup(int len, int* IDs) {
    1294:	e92d4800 	push	{r11, lr}
    1298:	e28db004 	add	r11, sp, #4
    129c:	e24dd008 	sub	sp, sp, #8
    12a0:	e50b0008 	str	r0, [r11, #-8]
    12a4:	e50b100c 	str	r1, [r11, #-12]
	disable_A9_interrupts();
    12a8:	ebffff0e 	bl	ee8 <disable_A9_interrupts>
	set_A9_IRQ_stack();
    12ac:	ebffff21 	bl	f38 <set_A9_IRQ_stack>
	fix_bug();
    12b0:	ebffffeb 	bl	1264 <fix_bug>
	config_GIC(len, IDs);
    12b4:	e51b0008 	ldr	r0, [r11, #-8]
    12b8:	e51b100c 	ldr	r1, [r11, #-12]
    12bc:	ebffff5b 	bl	1030 <config_GIC>
	enable_A9_interrupts();
    12c0:	ebffff12 	bl	f10 <enable_A9_interrupts>
}
    12c4:	e24bd004 	sub	sp, r11, #4
    12c8:	e8bd8800 	pop	{r11, pc}

000012cc <atexit>:
    12cc:	e1a01000 	mov	r1, r0
    12d0:	e3a00000 	mov	r0, #0
    12d4:	e92d4008 	push	{r3, lr}
    12d8:	e1a02000 	mov	r2, r0
    12dc:	e1a03000 	mov	r3, r0
    12e0:	eb00000e 	bl	1320 <__register_exitproc>
    12e4:	e8bd4008 	pop	{r3, lr}
    12e8:	e12fff1e 	bx	lr

000012ec <exit>:
    12ec:	e92d4008 	push	{r3, lr}
    12f0:	e3a01000 	mov	r1, #0
    12f4:	e1a04000 	mov	r4, r0
    12f8:	eb000045 	bl	1414 <__call_exitprocs>
    12fc:	e59f3018 	ldr	r3, [pc, #24]	; 131c <exit+0x30>
    1300:	e5930000 	ldr	r0, [r3]
    1304:	e590303c 	ldr	r3, [r0, #60]	; 0x3c
    1308:	e3530000 	cmp	r3, #0
    130c:	11a0e00f 	movne	lr, pc
    1310:	112fff13 	bxne	r3
    1314:	e1a00004 	mov	r0, r4
    1318:	eb0000c9 	bl	1644 <_exit>
    131c:	000016f4 	.word	0x000016f4

00001320 <__register_exitproc>:
    1320:	e59fc0e4 	ldr	r12, [pc, #228]	; 140c <__register_exitproc+0xec>
    1324:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    1328:	e59c4000 	ldr	r4, [r12]
    132c:	e594c148 	ldr	r12, [r4, #328]	; 0x148
    1330:	e35c0000 	cmp	r12, #0
    1334:	0284cf53 	addeq	r12, r4, #332	; 0x14c
    1338:	e59c5004 	ldr	r5, [r12, #4]
    133c:	0584c148 	streq	r12, [r4, #328]	; 0x148
    1340:	e355001f 	cmp	r5, #31
    1344:	e24dd010 	sub	sp, sp, #16
    1348:	e1a06000 	mov	r6, r0
    134c:	da000015 	ble	13a8 <__register_exitproc+0x88>
    1350:	e59f00b8 	ldr	r0, [pc, #184]	; 1410 <__register_exitproc+0xf0>
    1354:	e3500000 	cmp	r0, #0
    1358:	1a000001 	bne	1364 <__register_exitproc+0x44>
    135c:	e3e00000 	mvn	r0, #0
    1360:	ea000018 	b	13c8 <__register_exitproc+0xa8>
    1364:	e3a00e19 	mov	r0, #400	; 0x190
    1368:	e58d100c 	str	r1, [sp, #12]
    136c:	e58d2008 	str	r2, [sp, #8]
    1370:	e58d3004 	str	r3, [sp, #4]
    1374:	e320f000 	nop	{0}
    1378:	e250c000 	subs	r12, r0, #0
    137c:	e59d100c 	ldr	r1, [sp, #12]
    1380:	e59d2008 	ldr	r2, [sp, #8]
    1384:	e59d3004 	ldr	r3, [sp, #4]
    1388:	0afffff3 	beq	135c <__register_exitproc+0x3c>
    138c:	e5945148 	ldr	r5, [r4, #328]	; 0x148
    1390:	e3a00000 	mov	r0, #0
    1394:	e58c0004 	str	r0, [r12, #4]
    1398:	e58c5000 	str	r5, [r12]
    139c:	e584c148 	str	r12, [r4, #328]	; 0x148
    13a0:	e58c0188 	str	r0, [r12, #392]	; 0x188
    13a4:	e58c018c 	str	r0, [r12, #396]	; 0x18c
    13a8:	e3560000 	cmp	r6, #0
    13ac:	e59c4004 	ldr	r4, [r12, #4]
    13b0:	1a000007 	bne	13d4 <__register_exitproc+0xb4>
    13b4:	e2843002 	add	r3, r4, #2
    13b8:	e2844001 	add	r4, r4, #1
    13bc:	e78c1103 	str	r1, [r12, r3, lsl #2]
    13c0:	e58c4004 	str	r4, [r12, #4]
    13c4:	e3a00000 	mov	r0, #0
    13c8:	e28dd010 	add	sp, sp, #16
    13cc:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
    13d0:	e12fff1e 	bx	lr
    13d4:	e3a00001 	mov	r0, #1
    13d8:	e1a00410 	lsl	r0, r0, r4
    13dc:	e08c8104 	add	r8, r12, r4, lsl #2
    13e0:	e3560002 	cmp	r6, #2
    13e4:	e59c7188 	ldr	r7, [r12, #392]	; 0x188
    13e8:	e5883108 	str	r3, [r8, #264]	; 0x108
    13ec:	059c318c 	ldreq	r3, [r12, #396]	; 0x18c
    13f0:	e1877000 	orr	r7, r7, r0
    13f4:	01830000 	orreq	r0, r3, r0
    13f8:	e1a05008 	mov	r5, r8
    13fc:	e5882088 	str	r2, [r8, #136]	; 0x88
    1400:	e58c7188 	str	r7, [r12, #392]	; 0x188
    1404:	058c018c 	streq	r0, [r12, #396]	; 0x18c
    1408:	eaffffe9 	b	13b4 <__register_exitproc+0x94>
    140c:	000016f4 	.word	0x000016f4
    1410:	00000000 	.word	0x00000000

00001414 <__call_exitprocs>:
    1414:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
    1418:	e59f3168 	ldr	r3, [pc, #360]	; 1588 <__call_exitprocs+0x174>
    141c:	e5933000 	ldr	r3, [r3]
    1420:	e24dd014 	sub	sp, sp, #20
    1424:	e58d3004 	str	r3, [sp, #4]
    1428:	e2833f52 	add	r3, r3, #328	; 0x148
    142c:	e58d0008 	str	r0, [sp, #8]
    1430:	e58d300c 	str	r3, [sp, #12]
    1434:	e1a07001 	mov	r7, r1
    1438:	e3a08001 	mov	r8, #1
    143c:	e59d3004 	ldr	r3, [sp, #4]
    1440:	e5936148 	ldr	r6, [r3, #328]	; 0x148
    1444:	e3560000 	cmp	r6, #0
    1448:	e59db00c 	ldr	r11, [sp, #12]
    144c:	0a000033 	beq	1520 <__call_exitprocs+0x10c>
    1450:	e5965004 	ldr	r5, [r6, #4]
    1454:	e2554001 	subs	r4, r5, #1
    1458:	5286a088 	addpl	r10, r6, #136	; 0x88
    145c:	5285501f 	addpl	r5, r5, #31
    1460:	508a5105 	addpl	r5, r10, r5, lsl #2
    1464:	5a000007 	bpl	1488 <__call_exitprocs+0x74>
    1468:	ea000029 	b	1514 <__call_exitprocs+0x100>
    146c:	e5953000 	ldr	r3, [r5]
    1470:	e1530007 	cmp	r3, r7
    1474:	0a000005 	beq	1490 <__call_exitprocs+0x7c>
    1478:	e2444001 	sub	r4, r4, #1
    147c:	e3740001 	cmn	r4, #1
    1480:	e2455004 	sub	r5, r5, #4
    1484:	0a000022 	beq	1514 <__call_exitprocs+0x100>
    1488:	e3570000 	cmp	r7, #0
    148c:	1afffff6 	bne	146c <__call_exitprocs+0x58>
    1490:	e5963004 	ldr	r3, [r6, #4]
    1494:	e06a2005 	rsb	r2, r10, r5
    1498:	e2433001 	sub	r3, r3, #1
    149c:	e0862002 	add	r2, r6, r2
    14a0:	e1530004 	cmp	r3, r4
    14a4:	e5123078 	ldr	r3, [r2, #-120]	; 0xffffff88
    14a8:	13a01000 	movne	r1, #0
    14ac:	05864004 	streq	r4, [r6, #4]
    14b0:	15021078 	strne	r1, [r2, #-120]	; 0xffffff88
    14b4:	e3530000 	cmp	r3, #0
    14b8:	0affffee 	beq	1478 <__call_exitprocs+0x64>
    14bc:	e1a02418 	lsl	r2, r8, r4
    14c0:	e5961188 	ldr	r1, [r6, #392]	; 0x188
    14c4:	e1120001 	tst	r2, r1
    14c8:	e5969004 	ldr	r9, [r6, #4]
    14cc:	0a000016 	beq	152c <__call_exitprocs+0x118>
    14d0:	e596118c 	ldr	r1, [r6, #396]	; 0x18c
    14d4:	e1120001 	tst	r2, r1
    14d8:	1a000016 	bne	1538 <__call_exitprocs+0x124>
    14dc:	e59d0008 	ldr	r0, [sp, #8]
    14e0:	e5151080 	ldr	r1, [r5, #-128]	; 0xffffff80
    14e4:	e1a0e00f 	mov	lr, pc
    14e8:	e12fff13 	bx	r3
    14ec:	e5963004 	ldr	r3, [r6, #4]
    14f0:	e1530009 	cmp	r3, r9
    14f4:	1affffd0 	bne	143c <__call_exitprocs+0x28>
    14f8:	e59b3000 	ldr	r3, [r11]
    14fc:	e1530006 	cmp	r3, r6
    1500:	1affffcd 	bne	143c <__call_exitprocs+0x28>
    1504:	e2444001 	sub	r4, r4, #1
    1508:	e3740001 	cmn	r4, #1
    150c:	e2455004 	sub	r5, r5, #4
    1510:	1affffdc 	bne	1488 <__call_exitprocs+0x74>
    1514:	e59f1070 	ldr	r1, [pc, #112]	; 158c <__call_exitprocs+0x178>
    1518:	e3510000 	cmp	r1, #0
    151c:	1a000009 	bne	1548 <__call_exitprocs+0x134>
    1520:	e28dd014 	add	sp, sp, #20
    1524:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
    1528:	e12fff1e 	bx	lr
    152c:	e1a0e00f 	mov	lr, pc
    1530:	e12fff13 	bx	r3
    1534:	eaffffec 	b	14ec <__call_exitprocs+0xd8>
    1538:	e5150080 	ldr	r0, [r5, #-128]	; 0xffffff80
    153c:	e1a0e00f 	mov	lr, pc
    1540:	e12fff13 	bx	r3
    1544:	eaffffe8 	b	14ec <__call_exitprocs+0xd8>
    1548:	e5963004 	ldr	r3, [r6, #4]
    154c:	e3530000 	cmp	r3, #0
    1550:	e5963000 	ldr	r3, [r6]
    1554:	1a000008 	bne	157c <__call_exitprocs+0x168>
    1558:	e3530000 	cmp	r3, #0
    155c:	0a000006 	beq	157c <__call_exitprocs+0x168>
    1560:	e1a00006 	mov	r0, r6
    1564:	e58b3000 	str	r3, [r11]
    1568:	e320f000 	nop	{0}
    156c:	e59b6000 	ldr	r6, [r11]
    1570:	e3560000 	cmp	r6, #0
    1574:	1affffb5 	bne	1450 <__call_exitprocs+0x3c>
    1578:	eaffffe8 	b	1520 <__call_exitprocs+0x10c>
    157c:	e1a0b006 	mov	r11, r6
    1580:	e1a06003 	mov	r6, r3
    1584:	eafffff9 	b	1570 <__call_exitprocs+0x15c>
    1588:	000016f4 	.word	0x000016f4
    158c:	00000000 	.word	0x00000000

00001590 <register_fini>:
    1590:	e92d4008 	push	{r3, lr}
    1594:	e59f3010 	ldr	r3, [pc, #16]	; 15ac <register_fini+0x1c>
    1598:	e3530000 	cmp	r3, #0
    159c:	159f000c 	ldrne	r0, [pc, #12]	; 15b0 <register_fini+0x20>
    15a0:	1bffff49 	blne	12cc <atexit>
    15a4:	e8bd4008 	pop	{r3, lr}
    15a8:	e12fff1e 	bx	lr
    15ac:	0000171c 	.word	0x0000171c
    15b0:	000015b4 	.word	0x000015b4

000015b4 <__libc_fini_array>:
    15b4:	e92d4038 	push	{r3, r4, r5, lr}
    15b8:	e59f5030 	ldr	r5, [pc, #48]	; 15f0 <__libc_fini_array+0x3c>
    15bc:	e59f4030 	ldr	r4, [pc, #48]	; 15f4 <__libc_fini_array+0x40>
    15c0:	e0654004 	rsb	r4, r5, r4
    15c4:	e1b04144 	asrs	r4, r4, #2
    15c8:	10855104 	addne	r5, r5, r4, lsl #2
    15cc:	0a000004 	beq	15e4 <__libc_fini_array+0x30>
    15d0:	e5353004 	ldr	r3, [r5, #-4]!
    15d4:	e1a0e00f 	mov	lr, pc
    15d8:	e12fff13 	bx	r3
    15dc:	e2544001 	subs	r4, r4, #1
    15e0:	1afffffa 	bne	15d0 <__libc_fini_array+0x1c>
    15e4:	eb00004c 	bl	171c <__libc_fini>
    15e8:	e8bd4038 	pop	{r3, r4, r5, lr}
    15ec:	e12fff1e 	bx	lr
    15f0:	00001734 	.word	0x00001734
    15f4:	00001738 	.word	0x00001738

000015f8 <__cs3_premain>:
    15f8:	e92d4008 	push	{r3, lr}
    15fc:	eb000017 	bl	1660 <__libc_init_array>
    1600:	e59f3030 	ldr	r3, [pc, #48]	; 1638 <__cs3_premain+0x40>
    1604:	e3530000 	cmp	r3, #0
    1608:	15930000 	ldrne	r0, [r3]
    160c:	01a00003 	moveq	r0, r3
    1610:	e59f3024 	ldr	r3, [pc, #36]	; 163c <__cs3_premain+0x44>
    1614:	e3530000 	cmp	r3, #0
    1618:	15931000 	ldrne	r1, [r3]
    161c:	01a01003 	moveq	r1, r3
    1620:	e3a02000 	mov	r2, #0
    1624:	ebfffb0c 	bl	25c <main>
    1628:	e59f3010 	ldr	r3, [pc, #16]	; 1640 <__cs3_premain+0x48>
    162c:	e3530000 	cmp	r3, #0
    1630:	1bffff2d 	blne	12ec <exit>
    1634:	eafffffe 	b	1634 <__cs3_premain+0x3c>
	...
    1640:	000012ec 	.word	0x000012ec

00001644 <_exit>:
    1644:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    1648:	e3a00018 	mov	r0, #24
    164c:	e59f1004 	ldr	r1, [pc, #4]	; 1658 <_exit+0x14>
    1650:	ef123456 	svc	0x00123456
    1654:	eafffffe 	b	1654 <_exit+0x10>
    1658:	00020026 	.word	0x00020026

0000165c <__cs3_isr_interrupt>:
    165c:	eafffffe 	b	165c <__cs3_isr_interrupt>

00001660 <__libc_init_array>:
    1660:	e92d4070 	push	{r4, r5, r6, lr}
    1664:	e59f506c 	ldr	r5, [pc, #108]	; 16d8 <__libc_init_array+0x78>
    1668:	e59f606c 	ldr	r6, [pc, #108]	; 16dc <__libc_init_array+0x7c>
    166c:	e0656006 	rsb	r6, r5, r6
    1670:	e1b06146 	asrs	r6, r6, #2
    1674:	12455004 	subne	r5, r5, #4
    1678:	13a04000 	movne	r4, #0
    167c:	0a000005 	beq	1698 <__libc_init_array+0x38>
    1680:	e5b53004 	ldr	r3, [r5, #4]!
    1684:	e2844001 	add	r4, r4, #1
    1688:	e1a0e00f 	mov	lr, pc
    168c:	e12fff13 	bx	r3
    1690:	e1560004 	cmp	r6, r4
    1694:	1afffff9 	bne	1680 <__libc_init_array+0x20>
    1698:	e59f5040 	ldr	r5, [pc, #64]	; 16e0 <__libc_init_array+0x80>
    169c:	e59f6040 	ldr	r6, [pc, #64]	; 16e4 <__libc_init_array+0x84>
    16a0:	e0656006 	rsb	r6, r5, r6
    16a4:	eb000014 	bl	16fc <_init>
    16a8:	e1b06146 	asrs	r6, r6, #2
    16ac:	12455004 	subne	r5, r5, #4
    16b0:	13a04000 	movne	r4, #0
    16b4:	0a000005 	beq	16d0 <__libc_init_array+0x70>
    16b8:	e5b53004 	ldr	r3, [r5, #4]!
    16bc:	e2844001 	add	r4, r4, #1
    16c0:	e1a0e00f 	mov	lr, pc
    16c4:	e12fff13 	bx	r3
    16c8:	e1560004 	cmp	r6, r4
    16cc:	1afffff9 	bne	16b8 <__libc_init_array+0x58>
    16d0:	e8bd4070 	pop	{r4, r5, r6, lr}
    16d4:	e12fff1e 	bx	lr
    16d8:	00001714 	.word	0x00001714
    16dc:	00001714 	.word	0x00001714
    16e0:	00001714 	.word	0x00001714
    16e4:	0000171c 	.word	0x0000171c

Disassembly of section .rodata:

000016ec <_global_impure_ptr-0x8>:
    16ec:	000000c7 	.word	0x000000c7
    16f0:	00000049 	.word	0x00000049

000016f4 <_global_impure_ptr>:
    16f4:	00001760 00000043                       `...C...

000016fc <_init>:
    16fc:	e1a0c00d 	mov	r12, sp
    1700:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr, pc}
    1704:	e24cb004 	sub	r11, r12, #4
    1708:	e24bd028 	sub	sp, r11, #40	; 0x28
    170c:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, r10, r11, sp, lr}
    1710:	e12fff1e 	bx	lr

00001714 <__init_array_start>:
    1714:	00001590 	.word	0x00001590

00001718 <__frame_dummy_init_array_entry>:
    1718:	00000208                                ....

0000171c <__libc_fini>:
    171c:	e1a0c00d 	mov	r12, sp
    1720:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, lr, pc}
    1724:	e24cb004 	sub	r11, r12, #4
    1728:	e24bd028 	sub	sp, r11, #40	; 0x28
    172c:	e89d6ff0 	ldm	sp, {r4, r5, r6, r7, r8, r9, r10, r11, sp, lr}
    1730:	e12fff1e 	bx	lr

00001734 <__fini_array_start>:
    1734:	000001c4 	.word	0x000001c4

00001738 <__cs3_regions>:
    1738:	00000000 	.word	0x00000000
    173c:	00000040 	.word	0x00000040
    1740:	00000040 	.word	0x00000040
    1744:	00001b50 	.word	0x00001b50
    1748:	00000020 	.word	0x00000020

0000174c <__cs3_regions_end>:
    174c:	00000000 	.word	0x00000000
